## Generated by scripts/scrape_process.R -- do not edit

# Base class for annotation models.
Annotation <- R6::R6Class("Annotation",
  inherit = Renderer,
  public = list(
    initialize = function(
      level = "annotation", visible = TRUE, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, plot = NA
    ) {
      super$initialize(level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$plot <- validate(plot, "Instance ( Plot  )")
    }
  ),
  private = list(
    # The plot to which this annotation is attached.
    plot = NULL # Instance ( Plot  )
  )
)

# Render an arrow as an annotation.
Arrow <- R6::R6Class("Arrow",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, end = NA, end_units = "data",
      line_alpha = list(value = 1), line_cap = "butt",
      line_color = list(value = "black"), line_dash = list(),
      line_dash_offset = 0L, line_join = "miter", line_width = list(value =
      1L), source = NA, start = NA, start_units = "data", x_end = NA,
      x_range_name = "default", x_start = NA, y_end = NA,
      y_range_name = "default", y_start = NA
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$end <- validate(end, "Instance ( ArrowHead  )")
      private$end_units <- validate(end_units, "Enum ( SpatialUnits  )")
      private$line_alpha <- validate(line_alpha, "NumberSpec")
      private$line_cap <- validate(line_cap, "Enum ( LineCap  )")
      private$line_color <- validate(line_color, "ColorSpec")
      private$line_dash <- validate(line_dash, "DashPattern")
      private$line_dash_offset <- validate(line_dash_offset, "Int")
      private$line_join <- validate(line_join, "Enum ( LineJoin  )")
      private$line_width <- validate(line_width, "NumberSpec")
      private$source <- validate(source, "Instance ( DataSource  )")
      private$start <- validate(start, "Instance ( ArrowHead  )")
      private$start_units <- validate(start_units, "Enum ( SpatialUnits  )")
      private$x_end <- validate(x_end, "NumberSpec")
      private$x_range_name <- validate(x_range_name, "String")
      private$x_start <- validate(x_start, "NumberSpec")
      private$y_end <- validate(y_end, "NumberSpec")
      private$y_range_name <- validate(y_range_name, "String")
      private$y_start <- validate(y_start, "NumberSpec")
    }
  ),
  private = list(
    # Instance of ArrowHead.
    end = NULL, # Instance ( ArrowHead  )
    # The unit type for the end_x and end_y attributes. Interpreted as “data
    # space” units by default.
    end_units = NULL, # Enum ( SpatialUnits  )
    # The line alpha values for the arrow body.
    line_alpha = NULL, # NumberSpec
    # The line cap values for the arrow body.
    line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the arrow body.
    line_color = NULL, # ColorSpec
    # The line dash values for the arrow body.
    line_dash = NULL, # DashPattern
    # The line dash offset values for the arrow body.
    line_dash_offset = NULL, # Int
    # The line join values for the arrow body.
    line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the arrow body.
    line_width = NULL, # NumberSpec
    # Local data source to use when rendering annotations on the plot.
    source = NULL, # Instance ( DataSource  )
    # Instance of ArrowHead.
    start = NULL, # Instance ( ArrowHead  )
    # The unit type for the start_x and start_y attributes. Interpreted as
    # “data space” units by default.
    start_units = NULL, # Enum ( SpatialUnits  )
    # The x-coordinates to locate the end of the arrows.
    x_end = NULL, # NumberSpec
    # A particular (named) x-range to use for computing screen locations when
    # rendering annotations on the plot. If unset, use the default x-range.
    x_range_name = NULL, # String
    # The x-coordinates to locate the start of the arrows.
    x_start = NULL, # NumberSpec
    # The y-coordinates to locate the end of the arrows.
    y_end = NULL, # NumberSpec
    # A particular (named) y-range to use for computing screen locations when
    # rendering annotations on the plot. If unset, use the default y-range.
    y_range_name = NULL, # String
    # The y-coordinates to locate the start of the arrows.
    y_start = NULL # NumberSpec
  )
)

# Render a shaded rectangular region as an annotation.
BoxAnnotation <- R6::R6Class("BoxAnnotation",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, bottom = NA, bottom_units = "data",
      fill_alpha = list(value = 0.4), fill_color = list(value = "#fff9ba"),
      left = NA, left_units = "data", line_alpha = list(value = 0.3),
      line_cap = "butt", line_color = list(value = "#cccccc"),
      line_dash = list(), line_dash_offset = 0L, line_join = "miter",
      line_width = list(value = 1L), render_mode = "canvas", right = NA,
      right_units = "data", top = NA, top_units = "data",
      x_range_name = "default", y_range_name = "default"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$bottom <- validate(bottom, "Either ( Auto , NumberSpec  )")
      private$bottom_units <- validate(bottom_units, "Enum ( SpatialUnits  )")
      private$fill_alpha <- validate(fill_alpha, "NumberSpec")
      private$fill_color <- validate(fill_color, "ColorSpec")
      private$left <- validate(left, "Either ( Auto , NumberSpec  )")
      private$left_units <- validate(left_units, "Enum ( SpatialUnits  )")
      private$line_alpha <- validate(line_alpha, "NumberSpec")
      private$line_cap <- validate(line_cap, "Enum ( LineCap  )")
      private$line_color <- validate(line_color, "ColorSpec")
      private$line_dash <- validate(line_dash, "DashPattern")
      private$line_dash_offset <- validate(line_dash_offset, "Int")
      private$line_join <- validate(line_join, "Enum ( LineJoin  )")
      private$line_width <- validate(line_width, "NumberSpec")
      private$render_mode <- validate(render_mode, "Enum ( RenderMode  )")
      private$right <- validate(right, "Either ( Auto , NumberSpec  )")
      private$right_units <- validate(right_units, "Enum ( SpatialUnits  )")
      private$top <- validate(top, "Either ( Auto , NumberSpec  )")
      private$top_units <- validate(top_units, "Enum ( SpatialUnits  )")
      private$x_range_name <- validate(x_range_name, "String")
      private$y_range_name <- validate(y_range_name, "String")
    }
  ),
  private = list(
    # The y-coordinates of the bottom edge of the box annotation.
    bottom = NULL, # Either ( Auto , NumberSpec  )
    # The unit type for the bottom attribute. Interpreted as “data space”
    # units by default.
    bottom_units = NULL, # Enum ( SpatialUnits  )
    # The fill alpha values for the box.
    fill_alpha = NULL, # NumberSpec
    # The fill color values for the box.
    fill_color = NULL, # ColorSpec
    # The x-coordinates of the left edge of the box annotation.
    left = NULL, # Either ( Auto , NumberSpec  )
    # The unit type for the left attribute. Interpreted as “data space” units
    # by default.
    left_units = NULL, # Enum ( SpatialUnits  )
    # The line alpha values for the box.
    line_alpha = NULL, # NumberSpec
    # The line cap values for the box.
    line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the box.
    line_color = NULL, # ColorSpec
    # The line dash values for the box.
    line_dash = NULL, # DashPattern
    # The line dash offset values for the box.
    line_dash_offset = NULL, # Int
    # The line join values for the box.
    line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the box.
    line_width = NULL, # NumberSpec
    # Specifies whether the box is rendered as a canvas element or as an css
    # element overlaid on the canvas. The default mode is “canvas”.
    render_mode = NULL, # Enum ( RenderMode  )
    # The x-coordinates of the right edge of the box annotation.
    right = NULL, # Either ( Auto , NumberSpec  )
    # The unit type for the right attribute. Interpreted as “data space”
    # units by default.
    right_units = NULL, # Enum ( SpatialUnits  )
    # The y-coordinates of the top edge of the box annotation.
    top = NULL, # Either ( Auto , NumberSpec  )
    # The unit type for the top attribute. Interpreted as “data space” units
    # by default.
    top_units = NULL, # Enum ( SpatialUnits  )
    # A particular (named) x-range to use for computing screen locations when
    # rendering box annotations on the plot. If unset, use the default
    # x-range.
    x_range_name = NULL, # String
    # A particular (named) y-range to use for computing screen locations when
    # rendering box annotations on the plot. If unset, use the default
    # y-range.
    y_range_name = NULL # String
  )
)

# Render a color bar based on a color mapper for a plot.
ColorBar <- R6::R6Class("ColorBar",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, background_fill_alpha = list(value = 0.95),
      background_fill_color = list(value = "#ffffff"),
      bar_line_alpha = list(value = 1), bar_line_cap = "butt",
      bar_line_color = list(value = NULL), bar_line_dash = list(),
      bar_line_dash_offset = 0L, bar_line_join = "miter",
      bar_line_width = list(value = 1L), border_line_alpha = list(value =
      1), border_line_cap = "butt", border_line_color = list(value = NULL),
      border_line_dash = list(), border_line_dash_offset = 0L,
      border_line_join = "miter", border_line_width = list(value = 1L),
      color_mapper = NA, formatter = NA, height = "auto", label_standoff = 5L,
      location = "top_right", major_label_text_align = "center",
      major_label_text_alpha = list(value = 1),
      major_label_text_baseline = "middle",
      major_label_text_color = list(value = "#444444"),
      major_label_text_font = "helvetica",
      major_label_text_font_size = list(value = "8pt"),
      major_label_text_font_style = "normal", major_tick_in = 5L,
      major_tick_line_alpha = list(value = 1),
      major_tick_line_cap = "butt", major_tick_line_color = list(value =
      "#ffffff"), major_tick_line_dash = list(),
      major_tick_line_dash_offset = 0L, major_tick_line_join = "miter",
      major_tick_line_width = list(value = 1L), major_tick_out = 0L,
      margin = 30L, minor_tick_in = 0L, minor_tick_line_alpha = list(value =
      1), minor_tick_line_cap = "butt", minor_tick_line_color = list(value
      = NULL), minor_tick_line_dash = list(),
      minor_tick_line_dash_offset = 0L, minor_tick_line_join = "miter",
      minor_tick_line_width = list(value = 1L), minor_tick_out = 0L,
      orientation = "vertical", padding = 10L, scale_alpha = 1, ticker = NA,
      title = NA, title_standoff = 2L, title_text_align = "left",
      title_text_alpha = list(value = 1), title_text_baseline = "bottom",
      title_text_color = list(value = "#444444"),
      title_text_font = "helvetica", title_text_font_size = list(value =
      "10pt"), title_text_font_style = "italic", width = "auto"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$background_fill_alpha <- validate(background_fill_alpha, "NumberSpec")
      private$background_fill_color <- validate(background_fill_color, "ColorSpec")
      private$bar_line_alpha <- validate(bar_line_alpha, "NumberSpec")
      private$bar_line_cap <- validate(bar_line_cap, "Enum ( LineCap  )")
      private$bar_line_color <- validate(bar_line_color, "ColorSpec")
      private$bar_line_dash <- validate(bar_line_dash, "DashPattern")
      private$bar_line_dash_offset <- validate(bar_line_dash_offset, "Int")
      private$bar_line_join <- validate(bar_line_join, "Enum ( LineJoin  )")
      private$bar_line_width <- validate(bar_line_width, "NumberSpec")
      private$border_line_alpha <- validate(border_line_alpha, "NumberSpec")
      private$border_line_cap <- validate(border_line_cap, "Enum ( LineCap  )")
      private$border_line_color <- validate(border_line_color, "ColorSpec")
      private$border_line_dash <- validate(border_line_dash, "DashPattern")
      private$border_line_dash_offset <- validate(border_line_dash_offset, "Int")
      private$border_line_join <- validate(border_line_join, "Enum ( LineJoin  )")
      private$border_line_width <- validate(border_line_width, "NumberSpec")
      private$color_mapper <- validate(color_mapper, "Instance ( ContinuousColorMapper  )")
      private$formatter <- validate(formatter, "Instance ( TickFormatter  )")
      private$height <- validate(height, "Either ( Auto , Int  )")
      private$label_standoff <- validate(label_standoff, "Int")
      private$location <- validate(location, "Either ( Enum ( LegendLocation  ), Tuple ( Float , Float  ) )")
      private$major_label_text_align <- validate(major_label_text_align, "Enum ( TextAlign  )")
      private$major_label_text_alpha <- validate(major_label_text_alpha, "NumberSpec")
      private$major_label_text_baseline <- validate(major_label_text_baseline, "Enum ( TextBaseline  )")
      private$major_label_text_color <- validate(major_label_text_color, "ColorSpec")
      private$major_label_text_font <- validate(major_label_text_font, "String")
      private$major_label_text_font_size <- validate(major_label_text_font_size, "FontSizeSpec")
      private$major_label_text_font_style <- validate(major_label_text_font_style, "Enum ( FontStyle  )")
      private$major_tick_in <- validate(major_tick_in, "Int")
      private$major_tick_line_alpha <- validate(major_tick_line_alpha, "NumberSpec")
      private$major_tick_line_cap <- validate(major_tick_line_cap, "Enum ( LineCap  )")
      private$major_tick_line_color <- validate(major_tick_line_color, "ColorSpec")
      private$major_tick_line_dash <- validate(major_tick_line_dash, "DashPattern")
      private$major_tick_line_dash_offset <- validate(major_tick_line_dash_offset, "Int")
      private$major_tick_line_join <- validate(major_tick_line_join, "Enum ( LineJoin  )")
      private$major_tick_line_width <- validate(major_tick_line_width, "NumberSpec")
      private$major_tick_out <- validate(major_tick_out, "Int")
      private$margin <- validate(margin, "Int")
      private$minor_tick_in <- validate(minor_tick_in, "Int")
      private$minor_tick_line_alpha <- validate(minor_tick_line_alpha, "NumberSpec")
      private$minor_tick_line_cap <- validate(minor_tick_line_cap, "Enum ( LineCap  )")
      private$minor_tick_line_color <- validate(minor_tick_line_color, "ColorSpec")
      private$minor_tick_line_dash <- validate(minor_tick_line_dash, "DashPattern")
      private$minor_tick_line_dash_offset <- validate(minor_tick_line_dash_offset, "Int")
      private$minor_tick_line_join <- validate(minor_tick_line_join, "Enum ( LineJoin  )")
      private$minor_tick_line_width <- validate(minor_tick_line_width, "NumberSpec")
      private$minor_tick_out <- validate(minor_tick_out, "Int")
      private$orientation <- validate(orientation, "Enum ( Orientation  )")
      private$padding <- validate(padding, "Int")
      private$scale_alpha <- validate(scale_alpha, "Float")
      private$ticker <- validate(ticker, "Instance ( Ticker  )")
      private$title <- validate(title, "String")
      private$title_standoff <- validate(title_standoff, "Int")
      private$title_text_align <- validate(title_text_align, "Enum ( TextAlign  )")
      private$title_text_alpha <- validate(title_text_alpha, "NumberSpec")
      private$title_text_baseline <- validate(title_text_baseline, "Enum ( TextBaseline  )")
      private$title_text_color <- validate(title_text_color, "ColorSpec")
      private$title_text_font <- validate(title_text_font, "String")
      private$title_text_font_size <- validate(title_text_font_size, "FontSizeSpec")
      private$title_text_font_style <- validate(title_text_font_style, "Enum ( FontStyle  )")
      private$width <- validate(width, "Either ( Auto , Int  )")
    }
  ),
  private = list(
    # The fill alpha for the color bar background style.
    background_fill_alpha = NULL, # NumberSpec
    # The fill color for the color bar background style.
    background_fill_color = NULL, # ColorSpec
    # The line alpha for the color scale bar outline.
    bar_line_alpha = NULL, # NumberSpec
    # The line cap for the color scale bar outline.
    bar_line_cap = NULL, # Enum ( LineCap  )
    # The line color for the color scale bar outline.
    bar_line_color = NULL, # ColorSpec
    # The line dash for the color scale bar outline.
    bar_line_dash = NULL, # DashPattern
    # The line dash offset for the color scale bar outline.
    bar_line_dash_offset = NULL, # Int
    # The line join for the color scale bar outline.
    bar_line_join = NULL, # Enum ( LineJoin  )
    # The line width for the color scale bar outline.
    bar_line_width = NULL, # NumberSpec
    # The line alpha for the color bar border outline.
    border_line_alpha = NULL, # NumberSpec
    # The line cap for the color bar border outline.
    border_line_cap = NULL, # Enum ( LineCap  )
    # The line color for the color bar border outline.
    border_line_color = NULL, # ColorSpec
    # The line dash for the color bar border outline.
    border_line_dash = NULL, # DashPattern
    # The line dash offset for the color bar border outline.
    border_line_dash_offset = NULL, # Int
    # The line join for the color bar border outline.
    border_line_join = NULL, # Enum ( LineJoin  )
    # The line width for the color bar border outline.
    border_line_width = NULL, # NumberSpec
    # A continuous color mapper containing a color palette to render.
    color_mapper = NULL, # Instance ( ContinuousColorMapper  )
    # A TickFormatter to use for formatting the visual appearance of ticks.
    formatter = NULL, # Instance ( TickFormatter  )
    # The height (in pixels) that the color scale should occupy.
    height = NULL, # Either ( Auto , Int  )
    # The distance (in pixels) to separate the tick labels from the color
    # bar.
    label_standoff = NULL, # Int
    # The location where the color bar should draw itself. It’s either one of
    # bokeh.core.enums.LegendLocation‘s enumerated values, or a (x, y) tuple
    # indicating an absolute location absolute location in screen coordinates
    # (pixels from the bottom-left corner).
    location = NULL, # Either ( Enum ( LegendLocation  ), Tuple ( Float , Float  ) )
    # The text align of the major tick labels.
    major_label_text_align = NULL, # Enum ( TextAlign  )
    # The text alpha of the major tick labels.
    major_label_text_alpha = NULL, # NumberSpec
    # The text baseline of the major tick labels.
    major_label_text_baseline = NULL, # Enum ( TextBaseline  )
    # The text color of the major tick labels.
    major_label_text_color = NULL, # ColorSpec
    # The text font of the major tick labels.
    major_label_text_font = NULL, # String
    # The text font size of the major tick labels.
    major_label_text_font_size = NULL, # FontSizeSpec
    # The text font style of the major tick labels.
    major_label_text_font_style = NULL, # Enum ( FontStyle  )
    # The distance (in pixels) that major ticks should extend into the main
    # plot area.
    major_tick_in = NULL, # Int
    # The line alpha of the major ticks.
    major_tick_line_alpha = NULL, # NumberSpec
    # The line cap of the major ticks.
    major_tick_line_cap = NULL, # Enum ( LineCap  )
    # The line color of the major ticks.
    major_tick_line_color = NULL, # ColorSpec
    # The line dash of the major ticks.
    major_tick_line_dash = NULL, # DashPattern
    # The line dash offset of the major ticks.
    major_tick_line_dash_offset = NULL, # Int
    # The line join of the major ticks.
    major_tick_line_join = NULL, # Enum ( LineJoin  )
    # The line width of the major ticks.
    major_tick_line_width = NULL, # NumberSpec
    # The distance (in pixels) that major ticks should extend out of the main
    # plot area.
    major_tick_out = NULL, # Int
    # Amount of margin (in pixels) around the outside of the color bar.
    margin = NULL, # Int
    # The distance (in pixels) that minor ticks should extend into the main
    # plot area.
    minor_tick_in = NULL, # Int
    # The line alpha of the minor ticks.
    minor_tick_line_alpha = NULL, # NumberSpec
    # The line cap of the minor ticks.
    minor_tick_line_cap = NULL, # Enum ( LineCap  )
    # The line color of the minor ticks.
    minor_tick_line_color = NULL, # ColorSpec
    # The line dash of the minor ticks.
    minor_tick_line_dash = NULL, # DashPattern
    # The line dash offset of the minor ticks.
    minor_tick_line_dash_offset = NULL, # Int
    # The line join of the minor ticks.
    minor_tick_line_join = NULL, # Enum ( LineJoin  )
    # The line width of the minor ticks.
    minor_tick_line_width = NULL, # NumberSpec
    # The distance (in pixels) that major ticks should extend out of the main
    # plot area.
    minor_tick_out = NULL, # Int
    # Whether the color bar should be oriented vertically or horizontally.
    orientation = NULL, # Enum ( Orientation  )
    # Amount of padding (in pixels) between the color scale and color bar
    # border.
    padding = NULL, # Int
    # The alpha with which to render the color scale.
    scale_alpha = NULL, # Float
    # A Ticker to use for computing locations of axis components.
    ticker = NULL, # Instance ( Ticker  )
    # The title text to render.
    title = NULL, # String
    # The distance (in pixels) to separate the title from the color bar.
    title_standoff = NULL, # Int
    # The text align values for the title text.
    title_text_align = NULL, # Enum ( TextAlign  )
    # The text alpha values for the title text.
    title_text_alpha = NULL, # NumberSpec
    # The text baseline values for the title text.
    title_text_baseline = NULL, # Enum ( TextBaseline  )
    # The text color values for the title text.
    title_text_color = NULL, # ColorSpec
    # The text font values for the title text.
    title_text_font = NULL, # String
    # The text font size values for the title text.
    title_text_font_size = NULL, # FontSizeSpec
    # The text font style values for the title text.
    title_text_font_style = NULL, # Enum ( FontStyle  )
    # The width (in pixels) that the color scale should occupy.
    width = NULL # Either ( Auto , Int  )
  )
)

# Render a single text box as an annotation.
Label <- R6::R6Class("Label",
  inherit = TextAnnotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, angle = 0L, angle_units = "rad",
      background_fill_alpha = list(value = 1),
      background_fill_color = list(value = NULL),
      border_line_alpha = list(value = 1), border_line_cap = "butt",
      border_line_color = list(value = NULL), border_line_dash = list(),
      border_line_dash_offset = 0L, border_line_join = "miter",
      border_line_width = list(value = 1L), render_mode = "canvas",
      text = NA, text_align = "left", text_alpha = list(value = 1),
      text_baseline = "bottom", text_color = list(value = "#444444"),
      text_font = "helvetica", text_font_size = list(value = "12pt"),
      text_font_style = "normal", x = NA, x_offset = 0L,
      x_range_name = "default", x_units = "data", y = NA, y_offset = 0L,
      y_range_name = "default", y_units = "data"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$angle <- validate(angle, "Angle")
      private$angle_units <- validate(angle_units, "Enum ( AngleUnits  )")
      private$background_fill_alpha <- validate(background_fill_alpha, "NumberSpec")
      private$background_fill_color <- validate(background_fill_color, "ColorSpec")
      private$border_line_alpha <- validate(border_line_alpha, "NumberSpec")
      private$border_line_cap <- validate(border_line_cap, "Enum ( LineCap  )")
      private$border_line_color <- validate(border_line_color, "ColorSpec")
      private$border_line_dash <- validate(border_line_dash, "DashPattern")
      private$border_line_dash_offset <- validate(border_line_dash_offset, "Int")
      private$border_line_join <- validate(border_line_join, "Enum ( LineJoin  )")
      private$border_line_width <- validate(border_line_width, "NumberSpec")
      private$render_mode <- validate(render_mode, "Enum ( RenderMode  )")
      private$text <- validate(text, "String")
      private$text_align <- validate(text_align, "Enum ( TextAlign  )")
      private$text_alpha <- validate(text_alpha, "NumberSpec")
      private$text_baseline <- validate(text_baseline, "Enum ( TextBaseline  )")
      private$text_color <- validate(text_color, "ColorSpec")
      private$text_font <- validate(text_font, "String")
      private$text_font_size <- validate(text_font_size, "FontSizeSpec")
      private$text_font_style <- validate(text_font_style, "Enum ( FontStyle  )")
      private$x <- validate(x, "Float")
      private$x_offset <- validate(x_offset, "Float")
      private$x_range_name <- validate(x_range_name, "String")
      private$x_units <- validate(x_units, "Enum ( SpatialUnits  )")
      private$y <- validate(y, "Float")
      private$y_offset <- validate(y_offset, "Float")
      private$y_range_name <- validate(y_range_name, "String")
      private$y_units <- validate(y_units, "Enum ( SpatialUnits  )")
    }
  ),
  private = list(
    # The angle to rotate the text, as measured from the horizontal.
    angle = NULL, # Angle
    # Acceptable values for units are "rad" and "deg"
    angle_units = NULL, # Enum ( AngleUnits  )
    # The fill alpha values for the text bounding box.
    background_fill_alpha = NULL, # NumberSpec
    # The fill color values for the text bounding box.
    background_fill_color = NULL, # ColorSpec
    # The line alpha values for the text bounding box.
    border_line_alpha = NULL, # NumberSpec
    # The line cap values for the text bounding box.
    border_line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the text bounding box.
    border_line_color = NULL, # ColorSpec
    # The line dash values for the text bounding box.
    border_line_dash = NULL, # DashPattern
    # The line dash offset values for the text bounding box.
    border_line_dash_offset = NULL, # Int
    # The line join values for the text bounding box.
    border_line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the text bounding box.
    border_line_width = NULL, # NumberSpec
    # Specifies whether the text is rendered as a canvas element or as an css
    # element overlaid on the canvas. The default mode is “canvas”.
    render_mode = NULL, # Enum ( RenderMode  )
    # The text value to render.
    text = NULL, # String
    # The text align values for the text.
    text_align = NULL, # Enum ( TextAlign  )
    # The text alpha values for the text.
    text_alpha = NULL, # NumberSpec
    # The text baseline values for the text.
    text_baseline = NULL, # Enum ( TextBaseline  )
    # The text color values for the text.
    text_color = NULL, # ColorSpec
    # The text font values for the text.
    text_font = NULL, # String
    # The text font size values for the text.
    text_font_size = NULL, # FontSizeSpec
    # The text font style values for the text.
    text_font_style = NULL, # Enum ( FontStyle  )
    # The x-coordinate in screen coordinates to locate the text anchors.
    x = NULL, # Float
    # Offset value to apply to the x-coordinate. This is useful, for
    # instance, if it is desired to “float” text a fixed distance in screen
    # units from a given data position.
    x_offset = NULL, # Float
    # A particular (named) x-range to use for computing screen location when
    # rendering an annotation on the plot. If unset, use the default x-range.
    x_range_name = NULL, # String
    # The unit type for the x attribute. Interpreted as “data space” units by
    # default.
    x_units = NULL, # Enum ( SpatialUnits  )
    # The y-coordinate in screen coordinates to locate the text anchors.
    y = NULL, # Float
    # Offset value to apply to the y-coordinate. This is useful, for
    # instance, if it is desired to “float” text a fixed distance in screen
    # units from a given data position.
    y_offset = NULL, # Float
    # A particular (named) y-range to use for computing screen location when
    # rendering an annotation on the plot. If unset, use the default y-range.
    y_range_name = NULL, # String
    # The unit type for the y attribute. Interpreted as “data space” units by
    # default.
    y_units = NULL # Enum ( SpatialUnits  )
  )
)

# Render a group of text boxes as annotations.
LabelSet <- R6::R6Class("LabelSet",
  inherit = TextAnnotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, angle = list(units = "rad", value = 0L),
      background_fill_alpha = list(value = 1),
      background_fill_color = list(value = NULL),
      border_line_alpha = list(value = 1), border_line_cap = "butt",
      border_line_color = list(value = NULL), border_line_dash = list(),
      border_line_dash_offset = 0L, border_line_join = "miter",
      border_line_width = list(value = 1L), render_mode = "canvas",
      source = NA, text = list(field = "text"), text_align = "left",
      text_alpha = list(value = 1), text_baseline = "bottom",
      text_color = list(value = "#444444"), text_font = "helvetica",
      text_font_size = list(value = "12pt"), text_font_style = "normal",
      x = NA, x_offset = list(value = 0L), x_range_name = "default",
      x_units = "data", y = NA, y_offset = list(value = 0L),
      y_range_name = "default", y_units = "data"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$angle <- validate(angle, "AngleSpec")
      private$background_fill_alpha <- validate(background_fill_alpha, "NumberSpec")
      private$background_fill_color <- validate(background_fill_color, "ColorSpec")
      private$border_line_alpha <- validate(border_line_alpha, "NumberSpec")
      private$border_line_cap <- validate(border_line_cap, "Enum ( LineCap  )")
      private$border_line_color <- validate(border_line_color, "ColorSpec")
      private$border_line_dash <- validate(border_line_dash, "DashPattern")
      private$border_line_dash_offset <- validate(border_line_dash_offset, "Int")
      private$border_line_join <- validate(border_line_join, "Enum ( LineJoin  )")
      private$border_line_width <- validate(border_line_width, "NumberSpec")
      private$render_mode <- validate(render_mode, "Enum ( RenderMode  )")
      private$source <- validate(source, "Instance ( DataSource  )")
      private$text <- validate(text, "StringSpec")
      private$text_align <- validate(text_align, "Enum ( TextAlign  )")
      private$text_alpha <- validate(text_alpha, "NumberSpec")
      private$text_baseline <- validate(text_baseline, "Enum ( TextBaseline  )")
      private$text_color <- validate(text_color, "ColorSpec")
      private$text_font <- validate(text_font, "String")
      private$text_font_size <- validate(text_font_size, "FontSizeSpec")
      private$text_font_style <- validate(text_font_style, "Enum ( FontStyle  )")
      private$x <- validate(x, "NumberSpec")
      private$x_offset <- validate(x_offset, "NumberSpec")
      private$x_range_name <- validate(x_range_name, "String")
      private$x_units <- validate(x_units, "Enum ( SpatialUnits  )")
      private$y <- validate(y, "NumberSpec")
      private$y_offset <- validate(y_offset, "NumberSpec")
      private$y_range_name <- validate(y_range_name, "String")
      private$y_units <- validate(y_units, "Enum ( SpatialUnits  )")
    }
  ),
  private = list(
    # The angles to rotate the text, as measured from the horizontal.
    angle = NULL, # AngleSpec
    # The fill alpha values for the text bounding box.
    background_fill_alpha = NULL, # NumberSpec
    # The fill color values for the text bounding box.
    background_fill_color = NULL, # ColorSpec
    # The line alpha values for the text bounding box.
    border_line_alpha = NULL, # NumberSpec
    # The line cap values for the text bounding box.
    border_line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the text bounding box.
    border_line_color = NULL, # ColorSpec
    # The line dash values for the text bounding box.
    border_line_dash = NULL, # DashPattern
    # The line dash offset values for the text bounding box.
    border_line_dash_offset = NULL, # Int
    # The line join values for the text bounding box.
    border_line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the text bounding box.
    border_line_width = NULL, # NumberSpec
    # Specifies whether the text is rendered as a canvas element or as an css
    # element overlaid on the canvas. The default mode is “canvas”.
    render_mode = NULL, # Enum ( RenderMode  )
    # Local data source to use when rendering annotations on the plot.
    source = NULL, # Instance ( DataSource  )
    # The text values to render.
    text = NULL, # StringSpec
    # The text align values for the text.
    text_align = NULL, # Enum ( TextAlign  )
    # The text alpha values for the text.
    text_alpha = NULL, # NumberSpec
    # The text baseline values for the text.
    text_baseline = NULL, # Enum ( TextBaseline  )
    # The text color values for the text.
    text_color = NULL, # ColorSpec
    # The text font values for the text.
    text_font = NULL, # String
    # The text font size values for the text.
    text_font_size = NULL, # FontSizeSpec
    # The text font style values for the text.
    text_font_style = NULL, # Enum ( FontStyle  )
    # The x-coordinates to locate the text anchors.
    x = NULL, # NumberSpec
    # Offset values to apply to the x-coordinates. This is useful, for
    # instance, if it is desired to “float” text a fixed distance in screen
    # units from a given data position.
    x_offset = NULL, # NumberSpec
    # A particular (named) x-range to use for computing screen locations when
    # rendering annotations on the plot. If unset, use the default x-range.
    x_range_name = NULL, # String
    # The unit type for the xs attribute. Interpreted as “data space” units
    # by default.
    x_units = NULL, # Enum ( SpatialUnits  )
    # The y-coordinates to locate the text anchors.
    y = NULL, # NumberSpec
    # Offset values to apply to the y-coordinates. This is useful, for
    # instance, if it is desired to “float” text a fixed distance in screen
    # units from a given data position.
    y_offset = NULL, # NumberSpec
    # A particular (named) y-range to use for computing screen locations when
    # rendering annotations on the plot. If unset, use the default y-range.
    y_range_name = NULL, # String
    # The unit type for the ys attribute. Interpreted as “data space” units
    # by default.
    y_units = NULL # Enum ( SpatialUnits  )
  )
)

# Render informational legends for a plot.
Legend <- R6::R6Class("Legend",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, background_fill_alpha = list(value = 0.95),
      background_fill_color = list(value = "#ffffff"),
      border_line_alpha = list(value = 0.5), border_line_cap = "butt",
      border_line_color = list(value = "#e5e5e5"),
      border_line_dash = list(), border_line_dash_offset = 0L,
      border_line_join = "miter", border_line_width = list(value = 1L),
      glyph_height = 20L, glyph_width = 20L, items = list(),
      label_height = 20L, label_standoff = 5L, label_text_align = "left",
      label_text_alpha = list(value = 1), label_text_baseline = "middle",
      label_text_color = list(value = "#444444"),
      label_text_font = "helvetica", label_text_font_size = list(value =
      "10pt"), label_text_font_style = "normal", label_width = 20L,
      location = "top_right", margin = 10L, orientation = "vertical",
      padding = 10L, spacing = 3L
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$background_fill_alpha <- validate(background_fill_alpha, "NumberSpec")
      private$background_fill_color <- validate(background_fill_color, "ColorSpec")
      private$border_line_alpha <- validate(border_line_alpha, "NumberSpec")
      private$border_line_cap <- validate(border_line_cap, "Enum ( LineCap  )")
      private$border_line_color <- validate(border_line_color, "ColorSpec")
      private$border_line_dash <- validate(border_line_dash, "DashPattern")
      private$border_line_dash_offset <- validate(border_line_dash_offset, "Int")
      private$border_line_join <- validate(border_line_join, "Enum ( LineJoin  )")
      private$border_line_width <- validate(border_line_width, "NumberSpec")
      private$glyph_height <- validate(glyph_height, "Int")
      private$glyph_width <- validate(glyph_width, "Int")
      private$items <- validate(items, "List ( Instance ( LegendItem  ) )")
      private$label_height <- validate(label_height, "Int")
      private$label_standoff <- validate(label_standoff, "Int")
      private$label_text_align <- validate(label_text_align, "Enum ( TextAlign  )")
      private$label_text_alpha <- validate(label_text_alpha, "NumberSpec")
      private$label_text_baseline <- validate(label_text_baseline, "Enum ( TextBaseline  )")
      private$label_text_color <- validate(label_text_color, "ColorSpec")
      private$label_text_font <- validate(label_text_font, "String")
      private$label_text_font_size <- validate(label_text_font_size, "FontSizeSpec")
      private$label_text_font_style <- validate(label_text_font_style, "Enum ( FontStyle  )")
      private$label_width <- validate(label_width, "Int")
      private$location <- validate(location, "Either ( Enum ( LegendLocation  ), Tuple ( Float , Float  ) )")
      private$margin <- validate(margin, "Int")
      private$orientation <- validate(orientation, "Enum ( Orientation  )")
      private$padding <- validate(padding, "Int")
      private$spacing <- validate(spacing, "Int")
    }
  ),
  private = list(
    # The fill alpha for the legend background style.
    background_fill_alpha = NULL, # NumberSpec
    # The fill color for the legend background style.
    background_fill_color = NULL, # ColorSpec
    # The line alpha for the legend border outline.
    border_line_alpha = NULL, # NumberSpec
    # The line cap for the legend border outline.
    border_line_cap = NULL, # Enum ( LineCap  )
    # The line color for the legend border outline.
    border_line_color = NULL, # ColorSpec
    # The line dash for the legend border outline.
    border_line_dash = NULL, # DashPattern
    # The line dash offset for the legend border outline.
    border_line_dash_offset = NULL, # Int
    # The line join for the legend border outline.
    border_line_join = NULL, # Enum ( LineJoin  )
    # The line width for the legend border outline.
    border_line_width = NULL, # NumberSpec
    # The height (in pixels) that the rendered legend glyph should occupy.
    glyph_height = NULL, # Int
    # The width (in pixels) that the rendered legend glyph should occupy.
    glyph_width = NULL, # Int
    # A list of legend items to be rendered in the legend. This can be
    # specified explicitly, for instance: But can also be given more
    # compactly as a list of tuples: where each tuple is of the form: (label,
    # renderers).
    items = NULL, # List ( Instance ( LegendItem  ) )
    # The minimum height (in pixels) of the area that legend labels should
    # occupy.
    label_height = NULL, # Int
    # The distance (in pixels) to separate the label from its associated
    # glyph.
    label_standoff = NULL, # Int
    # The text align for the legend labels.
    label_text_align = NULL, # Enum ( TextAlign  )
    # The text alpha for the legend labels.
    label_text_alpha = NULL, # NumberSpec
    # The text baseline for the legend labels.
    label_text_baseline = NULL, # Enum ( TextBaseline  )
    # The text color for the legend labels.
    label_text_color = NULL, # ColorSpec
    # The text font for the legend labels.
    label_text_font = NULL, # String
    # The text font size for the legend labels.
    label_text_font_size = NULL, # FontSizeSpec
    # The text font style for the legend labels.
    label_text_font_style = NULL, # Enum ( FontStyle  )
    # The minimum width (in pixels) of the area that legend labels should
    # occupy.
    label_width = NULL, # Int
    # The location where the legend should draw itself. It’s either one of
    # bokeh.core.enums.LegendLocation‘s enumerated values, or a (x, y) tuple
    # indicating an absolute location absolute location in screen coordinates
    # (pixels from the bottom-left corner).
    location = NULL, # Either ( Enum ( LegendLocation  ), Tuple ( Float , Float  ) )
    # Amount of margin around the legend.
    margin = NULL, # Int
    # Whether the legend entries should be placed vertically or horizontally
    # when they are layed out.
    orientation = NULL, # Enum ( Orientation  )
    # Amount of padding around the contents of the legend.
    padding = NULL, # Int
    # Amount of spacing between legend entries.
    spacing = NULL # Int
  )
)

# Bases: bokeh.model.Model
LegendItem <- R6::R6Class("LegendItem",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, label = NA, renderers = list()
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$label <- validate(label, "StringSpec")
      private$renderers <- validate(renderers, "List ( Instance ( GlyphRenderer  ) )")
    }
  ),
  private = list(
    # A label for this legend. Can be a string, or a column of a
    # ColumnDataSource. If label is a field, then it must be in the
    # renderers’ data_source.
    label = NULL, # StringSpec
    # A list of the glyph renderers to draw in the legend. If label is a
    # field, then all data_sources of renderers must be the same.
    renderers = NULL # List ( Instance ( GlyphRenderer  ) )
  )
)

# Render a shaded polygonal region as an annotation.
PolyAnnotation <- R6::R6Class("PolyAnnotation",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, fill_alpha = list(value = 0.4),
      fill_color = list(value = "#fff9ba"), line_alpha = list(value = 0.3),
      line_cap = "butt", line_color = list(value = "#cccccc"),
      line_dash = list(), line_dash_offset = 0L, line_join = "miter",
      line_width = list(value = 1L), x_range_name = "default", xs = list(),
      xs_units = "data", y_range_name = "default", ys = list(),
      ys_units = "data"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$fill_alpha <- validate(fill_alpha, "NumberSpec")
      private$fill_color <- validate(fill_color, "ColorSpec")
      private$line_alpha <- validate(line_alpha, "NumberSpec")
      private$line_cap <- validate(line_cap, "Enum ( LineCap  )")
      private$line_color <- validate(line_color, "ColorSpec")
      private$line_dash <- validate(line_dash, "DashPattern")
      private$line_dash_offset <- validate(line_dash_offset, "Int")
      private$line_join <- validate(line_join, "Enum ( LineJoin  )")
      private$line_width <- validate(line_width, "NumberSpec")
      private$x_range_name <- validate(x_range_name, "String")
      private$xs <- validate(xs, "Seq ( Float  )")
      private$xs_units <- validate(xs_units, "Enum ( SpatialUnits  )")
      private$y_range_name <- validate(y_range_name, "String")
      private$ys <- validate(ys, "Seq ( Float  )")
      private$ys_units <- validate(ys_units, "Enum ( SpatialUnits  )")
    }
  ),
  private = list(
    # The fill alpha values for the polygon.
    fill_alpha = NULL, # NumberSpec
    # The fill color values for the polygon.
    fill_color = NULL, # ColorSpec
    # The line alpha values for the polygon.
    line_alpha = NULL, # NumberSpec
    # The line cap values for the polygon.
    line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the polygon.
    line_color = NULL, # ColorSpec
    # The line dash values for the polygon.
    line_dash = NULL, # DashPattern
    # The line dash offset values for the polygon.
    line_dash_offset = NULL, # Int
    # The line join values for the polygon.
    line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the polygon.
    line_width = NULL, # NumberSpec
    # A particular (named) x-range to use for computing screen locations when
    # rendering box annotations on the plot. If unset, use the default
    # x-range.
    x_range_name = NULL, # String
    # The x-coordinates of the region to draw.
    xs = NULL, # Seq ( Float  )
    # The unit type for the xs attribute. Interpreted as “data space” units
    # by default.
    xs_units = NULL, # Enum ( SpatialUnits  )
    # A particular (named) y-range to use for computing screen locations when
    # rendering box annotations on the plot. If unset, use the default
    # y-range.
    y_range_name = NULL, # String
    # The y-coordinates of the region to draw.
    ys = NULL, # Seq ( Float  )
    # The unit type for the ys attribute. Interpreted as “data space” units
    # by default.
    ys_units = NULL # Enum ( SpatialUnits  )
  )
)

# Render a horizontal or vertical line span.
Span <- R6::R6Class("Span",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, dimension = "width", line_alpha = list(value =
      1), line_cap = "butt", line_color = list(value = "black"),
      line_dash = list(), line_dash_offset = 0L, line_join = "miter",
      line_width = list(value = 1L), location = NA, location_units = "data",
      render_mode = "canvas", x_range_name = "default",
      y_range_name = "default"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$dimension <- validate(dimension, "Enum ( Dimension  )")
      private$line_alpha <- validate(line_alpha, "NumberSpec")
      private$line_cap <- validate(line_cap, "Enum ( LineCap  )")
      private$line_color <- validate(line_color, "ColorSpec")
      private$line_dash <- validate(line_dash, "DashPattern")
      private$line_dash_offset <- validate(line_dash_offset, "Int")
      private$line_join <- validate(line_join, "Enum ( LineJoin  )")
      private$line_width <- validate(line_width, "NumberSpec")
      private$location <- validate(location, "Float")
      private$location_units <- validate(location_units, "Enum ( SpatialUnits  )")
      private$render_mode <- validate(render_mode, "Enum ( RenderMode  )")
      private$x_range_name <- validate(x_range_name, "String")
      private$y_range_name <- validate(y_range_name, "String")
    }
  ),
  private = list(
    # The direction of the span.
    dimension = NULL, # Enum ( Dimension  )
    # The line alpha values for the span.
    line_alpha = NULL, # NumberSpec
    # The line cap values for the span.
    line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the span.
    line_color = NULL, # ColorSpec
    # The line dash values for the span.
    line_dash = NULL, # DashPattern
    # The line dash offset values for the span.
    line_dash_offset = NULL, # Int
    # The line join values for the span.
    line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the span.
    line_width = NULL, # NumberSpec
    # The location of the span, along dimension.
    location = NULL, # Float
    # The unit type for the location attribute. Interpreted as “data space”
    # units by default.
    location_units = NULL, # Enum ( SpatialUnits  )
    # Specifies whether the span is rendered as a canvas element or as an css
    # element overlaid on the canvas. The default mode is “canvas”.
    render_mode = NULL, # Enum ( RenderMode  )
    # A particular (named) x-range to use for computing screen locations when
    # rendering annotations on the plot. If unset, use the default x-range.
    x_range_name = NULL, # String
    # A particular (named) y-range to use for computing screen locations when
    # rendering annotations on the plot. If unset, use the default y-range.
    y_range_name = NULL # String
  )
)

# Base class for annotation models.
TextAnnotation <- R6::R6Class("TextAnnotation",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Render a single title box as an annotation.
Title <- R6::R6Class("Title",
  inherit = TextAnnotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, align = "left",
      background_fill_alpha = list(value = 1),
      background_fill_color = list(value = NULL),
      border_line_alpha = list(value = 1), border_line_cap = "butt",
      border_line_color = list(value = NULL), border_line_dash = list(),
      border_line_dash_offset = 0L, border_line_join = "miter",
      border_line_width = list(value = 1L), offset = 0L,
      render_mode = "canvas", text = NA, text_alpha = list(value = 1),
      text_color = list(value = "#444444"), text_font = "helvetica",
      text_font_size = list(value = "10pt"), text_font_style = "bold"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$align <- validate(align, "Enum ( TextAlign  )")
      private$background_fill_alpha <- validate(background_fill_alpha, "NumberSpec")
      private$background_fill_color <- validate(background_fill_color, "ColorSpec")
      private$border_line_alpha <- validate(border_line_alpha, "NumberSpec")
      private$border_line_cap <- validate(border_line_cap, "Enum ( LineCap  )")
      private$border_line_color <- validate(border_line_color, "ColorSpec")
      private$border_line_dash <- validate(border_line_dash, "DashPattern")
      private$border_line_dash_offset <- validate(border_line_dash_offset, "Int")
      private$border_line_join <- validate(border_line_join, "Enum ( LineJoin  )")
      private$border_line_width <- validate(border_line_width, "NumberSpec")
      private$offset <- validate(offset, "Float")
      private$render_mode <- validate(render_mode, "Enum ( RenderMode  )")
      private$text <- validate(text, "String")
      private$text_alpha <- validate(text_alpha, "NumberSpec")
      private$text_color <- validate(text_color, "ColorSpec")
      private$text_font <- validate(text_font, "String")
      private$text_font_size <- validate(text_font_size, "FontSizeSpec")
      private$text_font_style <- validate(text_font_style, "Enum ( FontStyle  )")
    }
  ),
  private = list(
    # Location to align the title text.
    align = NULL, # Enum ( TextAlign  )
    # The fill alpha values for the text bounding box.
    background_fill_alpha = NULL, # NumberSpec
    # The fill color values for the text bounding box.
    background_fill_color = NULL, # ColorSpec
    # The line alpha values for the text bounding box.
    border_line_alpha = NULL, # NumberSpec
    # The line cap values for the text bounding box.
    border_line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the text bounding box.
    border_line_color = NULL, # ColorSpec
    # The line dash values for the text bounding box.
    border_line_dash = NULL, # DashPattern
    # The line dash offset values for the text bounding box.
    border_line_dash_offset = NULL, # Int
    # The line join values for the text bounding box.
    border_line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the text bounding box.
    border_line_width = NULL, # NumberSpec
    # Offset the text by a number of pixels (can be positive or negative).
    # Shifts the text in different directions based on the location of the
    # title:
    offset = NULL, # Float
    # Specifies whether the text is rendered as a canvas element or as an css
    # element overlaid on the canvas. The default mode is “canvas”.
    render_mode = NULL, # Enum ( RenderMode  )
    # The text value to render.
    text = NULL, # String
    # An alpha value to use to fill text with. Acceptable values are floating
    # point numbers between 0 (transparent) and 1 (opaque).
    text_alpha = NULL, # NumberSpec
    # A color to use to fill text with. Acceptable values are:
    text_color = NULL, # ColorSpec
    # Name of a font to use for rendering text, e.g., 'times', 'helvetica'.
    text_font = NULL, # String
    # 
    text_font_size = NULL, # FontSizeSpec
    # A style to use for rendering text. Acceptable values are:
    text_font_style = NULL # Enum ( FontStyle  )
  )
)

# Render a tooltip.
Tooltip <- R6::R6Class("Tooltip",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "overlay", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, attachment = "horizontal", inner_only = TRUE,
      show_arrow = TRUE
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$attachment <- validate(attachment, "Enum ( Enumeration(horizontal, vertical, left, right, above, below) )")
      private$inner_only <- validate(inner_only, "Bool")
      private$show_arrow <- validate(show_arrow, "Bool")
    }
  ),
  private = list(
    # Whether the tooltip should display to the left or right off the cursor
    # position or above or below it, or if it should be automatically placed
    # in the horizontal or vertical dimension.
    attachment = NULL, # Enum ( Enumeration(horizontal, vertical, left, right, above, below) )
    # Whether to display outside a central plot frame area.
    inner_only = NULL, # Bool
    # Whether tooltip’s arrow should be showed.
    show_arrow = NULL # Bool
  )
)

# Base class for arrow heads.
ArrowHead <- R6::R6Class("ArrowHead",
  inherit = Annotation,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Render a closed-body arrow head.
NormalHead <- R6::R6Class("NormalHead",
  inherit = ArrowHead,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, fill_alpha = list(value = 1),
      fill_color = list(value = "black"), line_alpha = list(value = 1),
      line_cap = "butt", line_color = list(value = "black"),
      line_dash = list(), line_dash_offset = 0L, line_join = "miter",
      line_width = list(value = 1L), size = 25L
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$fill_alpha <- validate(fill_alpha, "NumberSpec")
      private$fill_color <- validate(fill_color, "ColorSpec")
      private$line_alpha <- validate(line_alpha, "NumberSpec")
      private$line_cap <- validate(line_cap, "Enum ( LineCap  )")
      private$line_color <- validate(line_color, "ColorSpec")
      private$line_dash <- validate(line_dash, "DashPattern")
      private$line_dash_offset <- validate(line_dash_offset, "Int")
      private$line_join <- validate(line_join, "Enum ( LineJoin  )")
      private$line_width <- validate(line_width, "NumberSpec")
      private$size <- validate(size, "Float")
    }
  ),
  private = list(
    # The fill alpha values for the arrow head interior.
    fill_alpha = NULL, # NumberSpec
    # The fill color values for the arrow head interior.
    fill_color = NULL, # ColorSpec
    # The line alpha values for the arrow head outline.
    line_alpha = NULL, # NumberSpec
    # The line cap values for the arrow head outline.
    line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the arrow head outline.
    line_color = NULL, # ColorSpec
    # The line dash values for the arrow head outline.
    line_dash = NULL, # DashPattern
    # The line dash offset values for the arrow head outline.
    line_dash_offset = NULL, # Int
    # The line join values for the arrow head outline.
    line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the arrow head outline.
    line_width = NULL, # NumberSpec
    # The size, in pixels, of the arrow head.
    size = NULL # Float
  )
)

# Render an open-body arrow head.
OpenHead <- R6::R6Class("OpenHead",
  inherit = ArrowHead,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, line_alpha = list(value = 1), line_cap = "butt",
      line_color = list(value = "black"), line_dash = list(),
      line_dash_offset = 0L, line_join = "miter", line_width = list(value =
      1L), size = 25L
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$line_alpha <- validate(line_alpha, "NumberSpec")
      private$line_cap <- validate(line_cap, "Enum ( LineCap  )")
      private$line_color <- validate(line_color, "ColorSpec")
      private$line_dash <- validate(line_dash, "DashPattern")
      private$line_dash_offset <- validate(line_dash_offset, "Int")
      private$line_join <- validate(line_join, "Enum ( LineJoin  )")
      private$line_width <- validate(line_width, "NumberSpec")
      private$size <- validate(size, "Float")
    }
  ),
  private = list(
    # The line alpha values for the arrow head outline.
    line_alpha = NULL, # NumberSpec
    # The line cap values for the arrow head outline.
    line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the arrow head outline.
    line_color = NULL, # ColorSpec
    # The line dash values for the arrow head outline.
    line_dash = NULL, # DashPattern
    # The line dash offset values for the arrow head outline.
    line_dash_offset = NULL, # Int
    # The line join values for the arrow head outline.
    line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the arrow head outline.
    line_width = NULL, # NumberSpec
    # The size, in pixels, of the arrow head.
    size = NULL # Float
  )
)

# Render an vee-style arrow head.
VeeHead <- R6::R6Class("VeeHead",
  inherit = ArrowHead,
  public = list(
    initialize = function(
      plot = NA, level = "annotation", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, fill_alpha = list(value = 1),
      fill_color = list(value = "black"), line_alpha = list(value = 1),
      line_cap = "butt", line_color = list(value = "black"),
      line_dash = list(), line_dash_offset = 0L, line_join = "miter",
      line_width = list(value = 1L), size = 25L
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$fill_alpha <- validate(fill_alpha, "NumberSpec")
      private$fill_color <- validate(fill_color, "ColorSpec")
      private$line_alpha <- validate(line_alpha, "NumberSpec")
      private$line_cap <- validate(line_cap, "Enum ( LineCap  )")
      private$line_color <- validate(line_color, "ColorSpec")
      private$line_dash <- validate(line_dash, "DashPattern")
      private$line_dash_offset <- validate(line_dash_offset, "Int")
      private$line_join <- validate(line_join, "Enum ( LineJoin  )")
      private$line_width <- validate(line_width, "NumberSpec")
      private$size <- validate(size, "Float")
    }
  ),
  private = list(
    # The fill alpha values for the arrow head interior.
    fill_alpha = NULL, # NumberSpec
    # The fill color values for the arrow head interior.
    fill_color = NULL, # ColorSpec
    # The line alpha values for the arrow head outline.
    line_alpha = NULL, # NumberSpec
    # The line cap values for the arrow head outline.
    line_cap = NULL, # Enum ( LineCap  )
    # The line color values for the arrow head outline.
    line_color = NULL, # ColorSpec
    # The line dash values for the arrow head outline.
    line_dash = NULL, # DashPattern
    # The line dash offset values for the arrow head outline.
    line_dash_offset = NULL, # Int
    # The line join values for the arrow head outline.
    line_join = NULL, # Enum ( LineJoin  )
    # The line width values for the arrow head outline.
    line_width = NULL, # NumberSpec
    # The size, in pixels, of the arrow head.
    size = NULL # Float
  )
)

# A base class that defines common properties for all axis types. Axis is
# not generally useful to instantiate on its own.
Axis <- R6::R6Class("Axis",
  inherit = GuideRenderer,
  public = list(
    initialize = function(
      plot = NA, level = "overlay", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, axis_label = "", axis_label_standoff = 5L,
      axis_label_text_align = "left", axis_label_text_alpha = list(value =
      1), axis_label_text_baseline = "bottom",
      axis_label_text_color = list(value = "#444444"),
      axis_label_text_font = "helvetica",
      axis_label_text_font_size = list(value = "10pt"),
      axis_label_text_font_style = "italic", axis_line_alpha = list(value =
      1), axis_line_cap = "butt", axis_line_color = list(value = "black"),
      axis_line_dash = list(), axis_line_dash_offset = 0L,
      axis_line_join = "miter", axis_line_width = list(value = 1L),
      bounds = "auto", formatter = NA,
      major_label_orientation = "horizontal", major_label_standoff = 5L,
      major_label_text_align = "center",
      major_label_text_alpha = list(value = 1),
      major_label_text_baseline = "alphabetic",
      major_label_text_color = list(value = "#444444"),
      major_label_text_font = "helvetica",
      major_label_text_font_size = list(value = "8pt"),
      major_label_text_font_style = "normal", major_tick_in = 2L,
      major_tick_line_alpha = list(value = 1),
      major_tick_line_cap = "butt", major_tick_line_color = list(value =
      "black"), major_tick_line_dash = list(),
      major_tick_line_dash_offset = 0L, major_tick_line_join = "miter",
      major_tick_line_width = list(value = 1L), major_tick_out = 6L,
      minor_tick_in = 0L, minor_tick_line_alpha = list(value = 1),
      minor_tick_line_cap = "butt", minor_tick_line_color = list(value =
      "black"), minor_tick_line_dash = list(),
      minor_tick_line_dash_offset = 0L, minor_tick_line_join = "miter",
      minor_tick_line_width = list(value = 1L), minor_tick_out = 4L,
      ticker = NA, x_range_name = "default", y_range_name = "default"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$axis_label <- validate(axis_label, "String")
      private$axis_label_standoff <- validate(axis_label_standoff, "Int")
      private$axis_label_text_align <- validate(axis_label_text_align, "Enum ( TextAlign  )")
      private$axis_label_text_alpha <- validate(axis_label_text_alpha, "NumberSpec")
      private$axis_label_text_baseline <- validate(axis_label_text_baseline, "Enum ( TextBaseline  )")
      private$axis_label_text_color <- validate(axis_label_text_color, "ColorSpec")
      private$axis_label_text_font <- validate(axis_label_text_font, "String")
      private$axis_label_text_font_size <- validate(axis_label_text_font_size, "FontSizeSpec")
      private$axis_label_text_font_style <- validate(axis_label_text_font_style, "Enum ( FontStyle  )")
      private$axis_line_alpha <- validate(axis_line_alpha, "NumberSpec")
      private$axis_line_cap <- validate(axis_line_cap, "Enum ( LineCap  )")
      private$axis_line_color <- validate(axis_line_color, "ColorSpec")
      private$axis_line_dash <- validate(axis_line_dash, "DashPattern")
      private$axis_line_dash_offset <- validate(axis_line_dash_offset, "Int")
      private$axis_line_join <- validate(axis_line_join, "Enum ( LineJoin  )")
      private$axis_line_width <- validate(axis_line_width, "NumberSpec")
      private$bounds <- validate(bounds, "Either ( Auto , Tuple ( Float , Float  ), Tuple ( Datetime , Datetime  ) )")
      private$formatter <- validate(formatter, "Instance ( TickFormatter  )")
      private$major_label_orientation <- validate(major_label_orientation, "Either ( Enum ( Enumeration(horizontal, vertical) ), Float  )")
      private$major_label_standoff <- validate(major_label_standoff, "Int")
      private$major_label_text_align <- validate(major_label_text_align, "Enum ( TextAlign  )")
      private$major_label_text_alpha <- validate(major_label_text_alpha, "NumberSpec")
      private$major_label_text_baseline <- validate(major_label_text_baseline, "Enum ( TextBaseline  )")
      private$major_label_text_color <- validate(major_label_text_color, "ColorSpec")
      private$major_label_text_font <- validate(major_label_text_font, "String")
      private$major_label_text_font_size <- validate(major_label_text_font_size, "FontSizeSpec")
      private$major_label_text_font_style <- validate(major_label_text_font_style, "Enum ( FontStyle  )")
      private$major_tick_in <- validate(major_tick_in, "Int")
      private$major_tick_line_alpha <- validate(major_tick_line_alpha, "NumberSpec")
      private$major_tick_line_cap <- validate(major_tick_line_cap, "Enum ( LineCap  )")
      private$major_tick_line_color <- validate(major_tick_line_color, "ColorSpec")
      private$major_tick_line_dash <- validate(major_tick_line_dash, "DashPattern")
      private$major_tick_line_dash_offset <- validate(major_tick_line_dash_offset, "Int")
      private$major_tick_line_join <- validate(major_tick_line_join, "Enum ( LineJoin  )")
      private$major_tick_line_width <- validate(major_tick_line_width, "NumberSpec")
      private$major_tick_out <- validate(major_tick_out, "Int")
      private$minor_tick_in <- validate(minor_tick_in, "Int")
      private$minor_tick_line_alpha <- validate(minor_tick_line_alpha, "NumberSpec")
      private$minor_tick_line_cap <- validate(minor_tick_line_cap, "Enum ( LineCap  )")
      private$minor_tick_line_color <- validate(minor_tick_line_color, "ColorSpec")
      private$minor_tick_line_dash <- validate(minor_tick_line_dash, "DashPattern")
      private$minor_tick_line_dash_offset <- validate(minor_tick_line_dash_offset, "Int")
      private$minor_tick_line_join <- validate(minor_tick_line_join, "Enum ( LineJoin  )")
      private$minor_tick_line_width <- validate(minor_tick_line_width, "NumberSpec")
      private$minor_tick_out <- validate(minor_tick_out, "Int")
      private$ticker <- validate(ticker, "Instance ( Ticker  )")
      private$x_range_name <- validate(x_range_name, "String")
      private$y_range_name <- validate(y_range_name, "String")
    }
  ),
  private = list(
    # A text label for the axis, displayed parallel to the axis rule.
    axis_label = NULL, # String
    # The distance in pixels that the axis labels should be offset from the
    # tick labels.
    axis_label_standoff = NULL, # Int
    # The text align of the axis label.
    axis_label_text_align = NULL, # Enum ( TextAlign  )
    # The text alpha of the axis label.
    axis_label_text_alpha = NULL, # NumberSpec
    # The text baseline of the axis label.
    axis_label_text_baseline = NULL, # Enum ( TextBaseline  )
    # The text color of the axis label.
    axis_label_text_color = NULL, # ColorSpec
    # The text font of the axis label.
    axis_label_text_font = NULL, # String
    # The text font size of the axis label.
    axis_label_text_font_size = NULL, # FontSizeSpec
    # The text font style of the axis label.
    axis_label_text_font_style = NULL, # Enum ( FontStyle  )
    # The line alpha of the axis line.
    axis_line_alpha = NULL, # NumberSpec
    # The line cap of the axis line.
    axis_line_cap = NULL, # Enum ( LineCap  )
    # The line color of the axis line.
    axis_line_color = NULL, # ColorSpec
    # The line dash of the axis line.
    axis_line_dash = NULL, # DashPattern
    # The line dash offset of the axis line.
    axis_line_dash_offset = NULL, # Int
    # The line join of the axis line.
    axis_line_join = NULL, # Enum ( LineJoin  )
    # The line width of the axis line.
    axis_line_width = NULL, # NumberSpec
    # Bounds for the rendered axis. If unset, the axis will span the entire
    # plot in the given dimension.
    bounds = NULL, # Either ( Auto , Tuple ( Float , Float  ), Tuple ( Datetime , Datetime  ) )
    # A TickFormatter to use for formatting the visual appearance of ticks.
    formatter = NULL, # Instance ( TickFormatter  )
    # What direction the major label text should be oriented. If a i number
    # is supplied, the angle of the text is measured from horizontal.
    major_label_orientation = NULL, # Either ( Enum ( Enumeration(horizontal, vertical) ), Float  )
    # The distance in pixels that the major tick labels should be offset from
    # the associated ticks.
    major_label_standoff = NULL, # Int
    # The text align of the major tick labels.
    major_label_text_align = NULL, # Enum ( TextAlign  )
    # The text alpha of the major tick labels.
    major_label_text_alpha = NULL, # NumberSpec
    # The text baseline of the major tick labels.
    major_label_text_baseline = NULL, # Enum ( TextBaseline  )
    # The text color of the major tick labels.
    major_label_text_color = NULL, # ColorSpec
    # The text font of the major tick labels.
    major_label_text_font = NULL, # String
    # The text font size of the major tick labels.
    major_label_text_font_size = NULL, # FontSizeSpec
    # The text font style of the major tick labels.
    major_label_text_font_style = NULL, # Enum ( FontStyle  )
    # The distance in pixels that major ticks should extend into the main
    # plot area.
    major_tick_in = NULL, # Int
    # The line alpha of the major ticks.
    major_tick_line_alpha = NULL, # NumberSpec
    # The line cap of the major ticks.
    major_tick_line_cap = NULL, # Enum ( LineCap  )
    # The line color of the major ticks.
    major_tick_line_color = NULL, # ColorSpec
    # The line dash of the major ticks.
    major_tick_line_dash = NULL, # DashPattern
    # The line dash offset of the major ticks.
    major_tick_line_dash_offset = NULL, # Int
    # The line join of the major ticks.
    major_tick_line_join = NULL, # Enum ( LineJoin  )
    # The line width of the major ticks.
    major_tick_line_width = NULL, # NumberSpec
    # The distance in pixels that major ticks should extend out of the main
    # plot area.
    major_tick_out = NULL, # Int
    # The distance in pixels that minor ticks should extend into the main
    # plot area.
    minor_tick_in = NULL, # Int
    # The line alpha of the minor ticks.
    minor_tick_line_alpha = NULL, # NumberSpec
    # The line cap of the minor ticks.
    minor_tick_line_cap = NULL, # Enum ( LineCap  )
    # The line color of the minor ticks.
    minor_tick_line_color = NULL, # ColorSpec
    # The line dash of the minor ticks.
    minor_tick_line_dash = NULL, # DashPattern
    # The line dash offset of the minor ticks.
    minor_tick_line_dash_offset = NULL, # Int
    # The line join of the minor ticks.
    minor_tick_line_join = NULL, # Enum ( LineJoin  )
    # The line width of the minor ticks.
    minor_tick_line_width = NULL, # NumberSpec
    # The distance in pixels that major ticks should extend out of the main
    # plot area.
    minor_tick_out = NULL, # Int
    # A Ticker to use for computing locations of axis components.
    ticker = NULL, # Instance ( Ticker  )
    # A particular (named) x-range to use for computing screen locations when
    # rendering an axis on the plot. If unset, use the default x-range.
    x_range_name = NULL, # String
    # A particular (named) y-range to use for computing screen locations when
    # rendering an axis on the plot. If unset, use the default y-range.
    y_range_name = NULL # String
  )
)

# An axis that picks evenly spaced tick locations for a collection of
# categories/factors.
CategoricalAxis <- R6::R6Class("CategoricalAxis",
  inherit = Axis,
  public = list(
    initialize = function(
      axis_label = "", axis_label_standoff = 5L,
      axis_label_text_align = "left", axis_label_text_alpha = list(value =
      1), axis_label_text_baseline = "bottom",
      axis_label_text_color = list(value = "#444444"),
      axis_label_text_font = "helvetica",
      axis_label_text_font_size = list(value = "10pt"),
      axis_label_text_font_style = "italic", axis_line_alpha = list(value =
      1), axis_line_cap = "butt", axis_line_color = list(value = "black"),
      axis_line_dash = list(), axis_line_dash_offset = 0L,
      axis_line_join = "miter", axis_line_width = list(value = 1L),
      bounds = "auto", formatter = NA,
      major_label_orientation = "horizontal", major_label_standoff = 5L,
      major_label_text_align = "center",
      major_label_text_alpha = list(value = 1),
      major_label_text_baseline = "alphabetic",
      major_label_text_color = list(value = "#444444"),
      major_label_text_font = "helvetica",
      major_label_text_font_size = list(value = "8pt"),
      major_label_text_font_style = "normal", major_tick_in = 2L,
      major_tick_line_alpha = list(value = 1),
      major_tick_line_cap = "butt", major_tick_line_color = list(value =
      "black"), major_tick_line_dash = list(),
      major_tick_line_dash_offset = 0L, major_tick_line_join = "miter",
      major_tick_line_width = list(value = 1L), major_tick_out = 6L,
      minor_tick_in = 0L, minor_tick_line_alpha = list(value = 1),
      minor_tick_line_cap = "butt", minor_tick_line_color = list(value =
      "black"), minor_tick_line_dash = list(),
      minor_tick_line_dash_offset = 0L, minor_tick_line_join = "miter",
      minor_tick_line_width = list(value = 1L), minor_tick_out = 4L,
      ticker = NA, x_range_name = "default", y_range_name = "default",
      plot = NA, level = "overlay", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(axis_label = axis_label,
        axis_label_standoff = axis_label_standoff,
        axis_label_text_align = axis_label_text_align,
        axis_label_text_alpha = axis_label_text_alpha,
        axis_label_text_baseline = axis_label_text_baseline,
        axis_label_text_color = axis_label_text_color,
        axis_label_text_font = axis_label_text_font,
        axis_label_text_font_size = axis_label_text_font_size,
        axis_label_text_font_style = axis_label_text_font_style,
        axis_line_alpha = axis_line_alpha, axis_line_cap = axis_line_cap,
        axis_line_color = axis_line_color, axis_line_dash = axis_line_dash,
        axis_line_dash_offset = axis_line_dash_offset,
        axis_line_join = axis_line_join, axis_line_width = axis_line_width,
        bounds = bounds, formatter = formatter,
        major_label_orientation = major_label_orientation,
        major_label_standoff = major_label_standoff,
        major_label_text_align = major_label_text_align,
        major_label_text_alpha = major_label_text_alpha,
        major_label_text_baseline = major_label_text_baseline,
        major_label_text_color = major_label_text_color,
        major_label_text_font = major_label_text_font,
        major_label_text_font_size = major_label_text_font_size,
        major_label_text_font_style = major_label_text_font_style,
        major_tick_in = major_tick_in,
        major_tick_line_alpha = major_tick_line_alpha,
        major_tick_line_cap = major_tick_line_cap,
        major_tick_line_color = major_tick_line_color,
        major_tick_line_dash = major_tick_line_dash,
        major_tick_line_dash_offset = major_tick_line_dash_offset,
        major_tick_line_join = major_tick_line_join,
        major_tick_line_width = major_tick_line_width,
        major_tick_out = major_tick_out, minor_tick_in = minor_tick_in,
        minor_tick_line_alpha = minor_tick_line_alpha,
        minor_tick_line_cap = minor_tick_line_cap,
        minor_tick_line_color = minor_tick_line_color,
        minor_tick_line_dash = minor_tick_line_dash,
        minor_tick_line_dash_offset = minor_tick_line_dash_offset,
        minor_tick_line_join = minor_tick_line_join,
        minor_tick_line_width = minor_tick_line_width,
        minor_tick_out = minor_tick_out, ticker = ticker,
        x_range_name = x_range_name, y_range_name = y_range_name,
        plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# A base class for all numeric, non-categorical axes types.
# ContinuousAxis is not generally useful to instantiate on its own.
ContinuousAxis <- R6::R6Class("ContinuousAxis",
  inherit = Axis,
  public = list(
    initialize = function(
      axis_label = "", axis_label_standoff = 5L,
      axis_label_text_align = "left", axis_label_text_alpha = list(value =
      1), axis_label_text_baseline = "bottom",
      axis_label_text_color = list(value = "#444444"),
      axis_label_text_font = "helvetica",
      axis_label_text_font_size = list(value = "10pt"),
      axis_label_text_font_style = "italic", axis_line_alpha = list(value =
      1), axis_line_cap = "butt", axis_line_color = list(value = "black"),
      axis_line_dash = list(), axis_line_dash_offset = 0L,
      axis_line_join = "miter", axis_line_width = list(value = 1L),
      bounds = "auto", formatter = NA,
      major_label_orientation = "horizontal", major_label_standoff = 5L,
      major_label_text_align = "center",
      major_label_text_alpha = list(value = 1),
      major_label_text_baseline = "alphabetic",
      major_label_text_color = list(value = "#444444"),
      major_label_text_font = "helvetica",
      major_label_text_font_size = list(value = "8pt"),
      major_label_text_font_style = "normal", major_tick_in = 2L,
      major_tick_line_alpha = list(value = 1),
      major_tick_line_cap = "butt", major_tick_line_color = list(value =
      "black"), major_tick_line_dash = list(),
      major_tick_line_dash_offset = 0L, major_tick_line_join = "miter",
      major_tick_line_width = list(value = 1L), major_tick_out = 6L,
      minor_tick_in = 0L, minor_tick_line_alpha = list(value = 1),
      minor_tick_line_cap = "butt", minor_tick_line_color = list(value =
      "black"), minor_tick_line_dash = list(),
      minor_tick_line_dash_offset = 0L, minor_tick_line_join = "miter",
      minor_tick_line_width = list(value = 1L), minor_tick_out = 4L,
      ticker = NA, x_range_name = "default", y_range_name = "default",
      plot = NA, level = "overlay", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(axis_label = axis_label,
        axis_label_standoff = axis_label_standoff,
        axis_label_text_align = axis_label_text_align,
        axis_label_text_alpha = axis_label_text_alpha,
        axis_label_text_baseline = axis_label_text_baseline,
        axis_label_text_color = axis_label_text_color,
        axis_label_text_font = axis_label_text_font,
        axis_label_text_font_size = axis_label_text_font_size,
        axis_label_text_font_style = axis_label_text_font_style,
        axis_line_alpha = axis_line_alpha, axis_line_cap = axis_line_cap,
        axis_line_color = axis_line_color, axis_line_dash = axis_line_dash,
        axis_line_dash_offset = axis_line_dash_offset,
        axis_line_join = axis_line_join, axis_line_width = axis_line_width,
        bounds = bounds, formatter = formatter,
        major_label_orientation = major_label_orientation,
        major_label_standoff = major_label_standoff,
        major_label_text_align = major_label_text_align,
        major_label_text_alpha = major_label_text_alpha,
        major_label_text_baseline = major_label_text_baseline,
        major_label_text_color = major_label_text_color,
        major_label_text_font = major_label_text_font,
        major_label_text_font_size = major_label_text_font_size,
        major_label_text_font_style = major_label_text_font_style,
        major_tick_in = major_tick_in,
        major_tick_line_alpha = major_tick_line_alpha,
        major_tick_line_cap = major_tick_line_cap,
        major_tick_line_color = major_tick_line_color,
        major_tick_line_dash = major_tick_line_dash,
        major_tick_line_dash_offset = major_tick_line_dash_offset,
        major_tick_line_join = major_tick_line_join,
        major_tick_line_width = major_tick_line_width,
        major_tick_out = major_tick_out, minor_tick_in = minor_tick_in,
        minor_tick_line_alpha = minor_tick_line_alpha,
        minor_tick_line_cap = minor_tick_line_cap,
        minor_tick_line_color = minor_tick_line_color,
        minor_tick_line_dash = minor_tick_line_dash,
        minor_tick_line_dash_offset = minor_tick_line_dash_offset,
        minor_tick_line_join = minor_tick_line_join,
        minor_tick_line_width = minor_tick_line_width,
        minor_tick_out = minor_tick_out, ticker = ticker,
        x_range_name = x_range_name, y_range_name = y_range_name,
        plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# An LinearAxis that picks nice numbers for tick locations on a datetime
# scale. Configured with a DatetimeTickFormatter by default.
DatetimeAxis <- R6::R6Class("DatetimeAxis",
  inherit = LinearAxis,
  public = list(
    initialize = function(
      axis_label = "", axis_label_standoff = 5L,
      axis_label_text_align = "left", axis_label_text_alpha = list(value =
      1), axis_label_text_baseline = "bottom",
      axis_label_text_color = list(value = "#444444"),
      axis_label_text_font = "helvetica",
      axis_label_text_font_size = list(value = "10pt"),
      axis_label_text_font_style = "italic", axis_line_alpha = list(value =
      1), axis_line_cap = "butt", axis_line_color = list(value = "black"),
      axis_line_dash = list(), axis_line_dash_offset = 0L,
      axis_line_join = "miter", axis_line_width = list(value = 1L),
      bounds = "auto", formatter = NA,
      major_label_orientation = "horizontal", major_label_standoff = 5L,
      major_label_text_align = "center",
      major_label_text_alpha = list(value = 1),
      major_label_text_baseline = "alphabetic",
      major_label_text_color = list(value = "#444444"),
      major_label_text_font = "helvetica",
      major_label_text_font_size = list(value = "8pt"),
      major_label_text_font_style = "normal", major_tick_in = 2L,
      major_tick_line_alpha = list(value = 1),
      major_tick_line_cap = "butt", major_tick_line_color = list(value =
      "black"), major_tick_line_dash = list(),
      major_tick_line_dash_offset = 0L, major_tick_line_join = "miter",
      major_tick_line_width = list(value = 1L), major_tick_out = 6L,
      minor_tick_in = 0L, minor_tick_line_alpha = list(value = 1),
      minor_tick_line_cap = "butt", minor_tick_line_color = list(value =
      "black"), minor_tick_line_dash = list(),
      minor_tick_line_dash_offset = 0L, minor_tick_line_join = "miter",
      minor_tick_line_width = list(value = 1L), minor_tick_out = 4L,
      ticker = NA, x_range_name = "default", y_range_name = "default",
      plot = NA, level = "overlay", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(axis_label = axis_label,
        axis_label_standoff = axis_label_standoff,
        axis_label_text_align = axis_label_text_align,
        axis_label_text_alpha = axis_label_text_alpha,
        axis_label_text_baseline = axis_label_text_baseline,
        axis_label_text_color = axis_label_text_color,
        axis_label_text_font = axis_label_text_font,
        axis_label_text_font_size = axis_label_text_font_size,
        axis_label_text_font_style = axis_label_text_font_style,
        axis_line_alpha = axis_line_alpha, axis_line_cap = axis_line_cap,
        axis_line_color = axis_line_color, axis_line_dash = axis_line_dash,
        axis_line_dash_offset = axis_line_dash_offset,
        axis_line_join = axis_line_join, axis_line_width = axis_line_width,
        bounds = bounds, formatter = formatter,
        major_label_orientation = major_label_orientation,
        major_label_standoff = major_label_standoff,
        major_label_text_align = major_label_text_align,
        major_label_text_alpha = major_label_text_alpha,
        major_label_text_baseline = major_label_text_baseline,
        major_label_text_color = major_label_text_color,
        major_label_text_font = major_label_text_font,
        major_label_text_font_size = major_label_text_font_size,
        major_label_text_font_style = major_label_text_font_style,
        major_tick_in = major_tick_in,
        major_tick_line_alpha = major_tick_line_alpha,
        major_tick_line_cap = major_tick_line_cap,
        major_tick_line_color = major_tick_line_color,
        major_tick_line_dash = major_tick_line_dash,
        major_tick_line_dash_offset = major_tick_line_dash_offset,
        major_tick_line_join = major_tick_line_join,
        major_tick_line_width = major_tick_line_width,
        major_tick_out = major_tick_out, minor_tick_in = minor_tick_in,
        minor_tick_line_alpha = minor_tick_line_alpha,
        minor_tick_line_cap = minor_tick_line_cap,
        minor_tick_line_color = minor_tick_line_color,
        minor_tick_line_dash = minor_tick_line_dash,
        minor_tick_line_dash_offset = minor_tick_line_dash_offset,
        minor_tick_line_join = minor_tick_line_join,
        minor_tick_line_width = minor_tick_line_width,
        minor_tick_out = minor_tick_out, ticker = ticker,
        x_range_name = x_range_name, y_range_name = y_range_name,
        plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# An axis that picks nice numbers for tick locations on a linear scale.
# Configured with a BasicTickFormatter by default.
LinearAxis <- R6::R6Class("LinearAxis",
  inherit = ContinuousAxis,
  public = list(
    initialize = function(
      axis_label = "", axis_label_standoff = 5L,
      axis_label_text_align = "left", axis_label_text_alpha = list(value =
      1), axis_label_text_baseline = "bottom",
      axis_label_text_color = list(value = "#444444"),
      axis_label_text_font = "helvetica",
      axis_label_text_font_size = list(value = "10pt"),
      axis_label_text_font_style = "italic", axis_line_alpha = list(value =
      1), axis_line_cap = "butt", axis_line_color = list(value = "black"),
      axis_line_dash = list(), axis_line_dash_offset = 0L,
      axis_line_join = "miter", axis_line_width = list(value = 1L),
      bounds = "auto", formatter = NA,
      major_label_orientation = "horizontal", major_label_standoff = 5L,
      major_label_text_align = "center",
      major_label_text_alpha = list(value = 1),
      major_label_text_baseline = "alphabetic",
      major_label_text_color = list(value = "#444444"),
      major_label_text_font = "helvetica",
      major_label_text_font_size = list(value = "8pt"),
      major_label_text_font_style = "normal", major_tick_in = 2L,
      major_tick_line_alpha = list(value = 1),
      major_tick_line_cap = "butt", major_tick_line_color = list(value =
      "black"), major_tick_line_dash = list(),
      major_tick_line_dash_offset = 0L, major_tick_line_join = "miter",
      major_tick_line_width = list(value = 1L), major_tick_out = 6L,
      minor_tick_in = 0L, minor_tick_line_alpha = list(value = 1),
      minor_tick_line_cap = "butt", minor_tick_line_color = list(value =
      "black"), minor_tick_line_dash = list(),
      minor_tick_line_dash_offset = 0L, minor_tick_line_join = "miter",
      minor_tick_line_width = list(value = 1L), minor_tick_out = 4L,
      ticker = NA, x_range_name = "default", y_range_name = "default",
      plot = NA, level = "overlay", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(axis_label = axis_label,
        axis_label_standoff = axis_label_standoff,
        axis_label_text_align = axis_label_text_align,
        axis_label_text_alpha = axis_label_text_alpha,
        axis_label_text_baseline = axis_label_text_baseline,
        axis_label_text_color = axis_label_text_color,
        axis_label_text_font = axis_label_text_font,
        axis_label_text_font_size = axis_label_text_font_size,
        axis_label_text_font_style = axis_label_text_font_style,
        axis_line_alpha = axis_line_alpha, axis_line_cap = axis_line_cap,
        axis_line_color = axis_line_color, axis_line_dash = axis_line_dash,
        axis_line_dash_offset = axis_line_dash_offset,
        axis_line_join = axis_line_join, axis_line_width = axis_line_width,
        bounds = bounds, formatter = formatter,
        major_label_orientation = major_label_orientation,
        major_label_standoff = major_label_standoff,
        major_label_text_align = major_label_text_align,
        major_label_text_alpha = major_label_text_alpha,
        major_label_text_baseline = major_label_text_baseline,
        major_label_text_color = major_label_text_color,
        major_label_text_font = major_label_text_font,
        major_label_text_font_size = major_label_text_font_size,
        major_label_text_font_style = major_label_text_font_style,
        major_tick_in = major_tick_in,
        major_tick_line_alpha = major_tick_line_alpha,
        major_tick_line_cap = major_tick_line_cap,
        major_tick_line_color = major_tick_line_color,
        major_tick_line_dash = major_tick_line_dash,
        major_tick_line_dash_offset = major_tick_line_dash_offset,
        major_tick_line_join = major_tick_line_join,
        major_tick_line_width = major_tick_line_width,
        major_tick_out = major_tick_out, minor_tick_in = minor_tick_in,
        minor_tick_line_alpha = minor_tick_line_alpha,
        minor_tick_line_cap = minor_tick_line_cap,
        minor_tick_line_color = minor_tick_line_color,
        minor_tick_line_dash = minor_tick_line_dash,
        minor_tick_line_dash_offset = minor_tick_line_dash_offset,
        minor_tick_line_join = minor_tick_line_join,
        minor_tick_line_width = minor_tick_line_width,
        minor_tick_out = minor_tick_out, ticker = ticker,
        x_range_name = x_range_name, y_range_name = y_range_name,
        plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# An axis that picks nice numbers for tick locations on a log scale.
# Configured with a LogTickFormatter by default.
LogAxis <- R6::R6Class("LogAxis",
  inherit = ContinuousAxis,
  public = list(
    initialize = function(
      axis_label = "", axis_label_standoff = 5L,
      axis_label_text_align = "left", axis_label_text_alpha = list(value =
      1), axis_label_text_baseline = "bottom",
      axis_label_text_color = list(value = "#444444"),
      axis_label_text_font = "helvetica",
      axis_label_text_font_size = list(value = "10pt"),
      axis_label_text_font_style = "italic", axis_line_alpha = list(value =
      1), axis_line_cap = "butt", axis_line_color = list(value = "black"),
      axis_line_dash = list(), axis_line_dash_offset = 0L,
      axis_line_join = "miter", axis_line_width = list(value = 1L),
      bounds = "auto", formatter = NA,
      major_label_orientation = "horizontal", major_label_standoff = 5L,
      major_label_text_align = "center",
      major_label_text_alpha = list(value = 1),
      major_label_text_baseline = "alphabetic",
      major_label_text_color = list(value = "#444444"),
      major_label_text_font = "helvetica",
      major_label_text_font_size = list(value = "8pt"),
      major_label_text_font_style = "normal", major_tick_in = 2L,
      major_tick_line_alpha = list(value = 1),
      major_tick_line_cap = "butt", major_tick_line_color = list(value =
      "black"), major_tick_line_dash = list(),
      major_tick_line_dash_offset = 0L, major_tick_line_join = "miter",
      major_tick_line_width = list(value = 1L), major_tick_out = 6L,
      minor_tick_in = 0L, minor_tick_line_alpha = list(value = 1),
      minor_tick_line_cap = "butt", minor_tick_line_color = list(value =
      "black"), minor_tick_line_dash = list(),
      minor_tick_line_dash_offset = 0L, minor_tick_line_join = "miter",
      minor_tick_line_width = list(value = 1L), minor_tick_out = 4L,
      ticker = NA, x_range_name = "default", y_range_name = "default",
      plot = NA, level = "overlay", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(axis_label = axis_label,
        axis_label_standoff = axis_label_standoff,
        axis_label_text_align = axis_label_text_align,
        axis_label_text_alpha = axis_label_text_alpha,
        axis_label_text_baseline = axis_label_text_baseline,
        axis_label_text_color = axis_label_text_color,
        axis_label_text_font = axis_label_text_font,
        axis_label_text_font_size = axis_label_text_font_size,
        axis_label_text_font_style = axis_label_text_font_style,
        axis_line_alpha = axis_line_alpha, axis_line_cap = axis_line_cap,
        axis_line_color = axis_line_color, axis_line_dash = axis_line_dash,
        axis_line_dash_offset = axis_line_dash_offset,
        axis_line_join = axis_line_join, axis_line_width = axis_line_width,
        bounds = bounds, formatter = formatter,
        major_label_orientation = major_label_orientation,
        major_label_standoff = major_label_standoff,
        major_label_text_align = major_label_text_align,
        major_label_text_alpha = major_label_text_alpha,
        major_label_text_baseline = major_label_text_baseline,
        major_label_text_color = major_label_text_color,
        major_label_text_font = major_label_text_font,
        major_label_text_font_size = major_label_text_font_size,
        major_label_text_font_style = major_label_text_font_style,
        major_tick_in = major_tick_in,
        major_tick_line_alpha = major_tick_line_alpha,
        major_tick_line_cap = major_tick_line_cap,
        major_tick_line_color = major_tick_line_color,
        major_tick_line_dash = major_tick_line_dash,
        major_tick_line_dash_offset = major_tick_line_dash_offset,
        major_tick_line_join = major_tick_line_join,
        major_tick_line_width = major_tick_line_width,
        major_tick_out = major_tick_out, minor_tick_in = minor_tick_in,
        minor_tick_line_alpha = minor_tick_line_alpha,
        minor_tick_line_cap = minor_tick_line_cap,
        minor_tick_line_color = minor_tick_line_color,
        minor_tick_line_dash = minor_tick_line_dash,
        minor_tick_line_dash_offset = minor_tick_line_dash_offset,
        minor_tick_line_join = minor_tick_line_join,
        minor_tick_line_width = minor_tick_line_width,
        minor_tick_out = minor_tick_out, ticker = ticker,
        x_range_name = x_range_name, y_range_name = y_range_name,
        plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Base class for interactive callback. Callback is generally not useful
# to instantiate on its own.
Callback <- R6::R6Class("Callback",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Execute a JavaScript function.
CustomJS <- R6::R6Class("CustomJS",
  inherit = Callback,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, args = structure(list(), .Names =
      character(0)), code = ""
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$args <- validate(args, "Dict ( String , Instance ( Model  ) )")
      private$code <- validate(code, "String")
    }
  ),
  private = list(
    # A mapping of names to Bokeh plot objects. These objects are made
    # available to the callback code snippet as the values of named
    # parameters to the callback.
    args = NULL, # Dict ( String , Instance ( Model  ) )
    # A snippet of JavaScript code to execute in the browser. The code is
    # made into the body of a function, and all of of the named objects in
    # args are available as parameters that the code can use. Additionally, a
    # cb_obj parameter contains the object that triggered the callback and an
    # optional cb_data parameter that contains any tool-specific data (i.e.
    # mouse coordinates and hovered glyph indices for the HoverTool).
    code = NULL # String
  )
)

# Open a URL in a new tab or window (browser dependent).
OpenURL <- R6::R6Class("OpenURL",
  inherit = Callback,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, url = "http://"
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$url <- validate(url, "String")
    }
  ),
  private = list(
    # The URL to direct the web browser to. This can be a template string,
    # which will be formatted with data from the data source.
    url = NULL # String
  )
)

# Display tick values from continuous ranges as “basic numbers”, using
# scientific notation when appropriate by default.
BasicTickFormatter <- R6::R6Class("BasicTickFormatter",
  inherit = TickFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, power_limit_high = 5L, power_limit_low = -3L,
      precision = "auto", use_scientific = TRUE
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$power_limit_high <- validate(power_limit_high, "Int")
      private$power_limit_low <- validate(power_limit_low, "Int")
      private$precision <- validate(precision, "Either ( Auto , Int  )")
      private$use_scientific <- validate(use_scientific, "Bool")
    }
  ),
  private = list(
    # Limit the use of scientific notation to when:
    power_limit_high = NULL, # Int
    # Limit the use of scientific notation to when:
    power_limit_low = NULL, # Int
    # How many digits of precision to display in tick labels.
    precision = NULL, # Either ( Auto , Int  )
    # Whether to ever display scientific notation. If True, then when to use
    # scientific notation is controlled by power_limit_low and
    # power_limit_high.
    use_scientific = NULL # Bool
  )
)

# Display tick values from categorical ranges as string values.
CategoricalTickFormatter <- R6::R6Class("CategoricalTickFormatter",
  inherit = TickFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# This list of supported strftime formats is reproduced below.
DatetimeTickFormatter <- R6::R6Class("DatetimeTickFormatter",
  inherit = TickFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, days = c("%m/%d", "%a%d"), hourmin = "%H:%M",
      hours = c("%Hh", "%H:%M"), microseconds = "%fus",
      milliseconds = c("%3Nms", "%S.%3Ns"), minsec = ":%M:%S",
      minutes = c(":%M", "%Mm"), months = c("%m/%Y", "%b%y"),
      seconds = "%Ss", years = "%Y"
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$days <- validate(days, "List ( String  )")
      private$hourmin <- validate(hourmin, "List ( String  )")
      private$hours <- validate(hours, "List ( String  )")
      private$microseconds <- validate(microseconds, "List ( String  )")
      private$milliseconds <- validate(milliseconds, "List ( String  )")
      private$minsec <- validate(minsec, "List ( String  )")
      private$minutes <- validate(minutes, "List ( String  )")
      private$months <- validate(months, "List ( String  )")
      private$seconds <- validate(seconds, "List ( String  )")
      private$years <- validate(years, "List ( String  )")
    }
  ),
  private = list(
    # Formats for displaying datetime values in the days range. See the
    # DatetimeTickFormatter help for a list of all supported formats.
    days = NULL, # List ( String  )
    # Formats for displaying datetime values in the hourmin (for combined
    # hours and minutes) range. See the DatetimeTickFormatter help for a list
    # of all supported formats.
    hourmin = NULL, # List ( String  )
    # Formats for displaying datetime values in the hours range. See the
    # DatetimeTickFormatter help for a list of all supported formats.
    hours = NULL, # List ( String  )
    # Formats for displaying datetime values in the microseconds range. See
    # the DatetimeTickFormatter help for a list of all supported formats.
    microseconds = NULL, # List ( String  )
    # Formats for displaying datetime values in the milliseconds range. See
    # the DatetimeTickFormatter help for a list of all supported formats.
    milliseconds = NULL, # List ( String  )
    # Formats for displaying datetime values in the minsec (for combined
    # minutes and seconds) range. See the DatetimeTickFormatter help for a
    # list of all supported formats.
    minsec = NULL, # List ( String  )
    # Formats for displaying datetime values in the minutes range. See the
    # DatetimeTickFormatter help for a list of all supported formats.
    minutes = NULL, # List ( String  )
    # Formats for displaying datetime values in the months range. See the
    # DatetimeTickFormatter help for a list of all supported formats.
    months = NULL, # List ( String  )
    # Formats for displaying datetime values in the seconds range. See the
    # DatetimeTickFormatter help for a list of all supported formats.
    seconds = NULL, # List ( String  )
    # Formats for displaying datetime values in the years range. See the
    # DatetimeTickFormatter help for a list of all supported formats.
    years = NULL # List ( String  )
  )
)

# Display tick values that are formatted by a user-defined function.
FuncTickFormatter <- R6::R6Class("FuncTickFormatter",
  inherit = TickFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, args = structure(list(), .Names =
      character(0)), code = ""
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$args <- validate(args, "Dict ( String , Instance ( Model  ) )")
      private$code <- validate(code, "String")
    }
  ),
  private = list(
    # A mapping of names to Bokeh plot objects. These objects are made
    # available to the formatter code snippet as the values of named
    # parameters to the callback.
    args = NULL, # Dict ( String , Instance ( Model  ) )
    # A snippet of JavaScript code that reformats a single tick to the
    # desired format. The variable tick will contain the unformatted tick
    # value and can be expected to be present in the code snippet namespace
    # at render time. Example:
    code = NULL # String
  )
)

# Most often useful in conjunction with a LogTicker.
LogTickFormatter <- R6::R6Class("LogTickFormatter",
  inherit = TickFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, ticker = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$ticker <- validate(ticker, "Instance ( Ticker  )")
    }
  ),
  private = list(
    # The corresponding LogTicker, used to determine the correct base to use.
    # If unset, the formatter will use base 10 as a default.
    ticker = NULL # Instance ( Ticker  )
  )
)

# Tick formatter based on a human-readable format string.
NumeralTickFormatter <- R6::R6Class("NumeralTickFormatter",
  inherit = TickFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, format = "0,0", language = "en", rounding = "round"
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$format <- validate(format, "String")
      private$language <- validate(language, "Enum ( NumeralLanguage  )")
      private$rounding <- validate(rounding, "Enum ( RoundingFunction  )")
    }
  ),
  private = list(
    # The number format, as defined in the following tables: NUMBERS:
    # CURRENCY: BYTES: PERCENTAGES: TIME: For the complete specification, see
    # http://numbrojs.com/format.html
    format = NULL, # String
    # The language to use for formatting language-specific features (e.g.
    # thousands separator).
    language = NULL, # Enum ( NumeralLanguage  )
    # Rounding functions (round, floor, ceil) and their synonyms (nearest,
    # rounddown, roundup).
    rounding = NULL # Enum ( RoundingFunction  )
  )
)

# Tick formatter based on a printf-style format string.
PrintfTickFormatter <- R6::R6Class("PrintfTickFormatter",
  inherit = TickFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, format = "%s"
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$format <- validate(format, "String")
    }
  ),
  private = list(
    # The number format, as defined as follows: the placeholder in the format
    # string is marked by % and is followed by one or more of these elements,
    # in this order: Causes the result to be preceded with a plus or minus
    # sign on numeric values. By default, only the - sign is used on negative
    # numbers. Specifies what (if any) character to use for padding. Possible
    # values are 0 or any other character preceded by a ' (single quote). The
    # default is to pad with spaces. Causes sprintf to left-align the result
    # of this placeholder. The default is to right-align the result.
    # Specifies how many characters the result should have. If the value to
    # be returned is shorter than this number, the result will be padded.
    # Consists of a . (dot) followed by a number, specifies how many digits
    # should be displayed for floating point numbers. When used on a string,
    # it causes the result to be truncated. Can be any of:
    format = NULL # String
  )
)

# A base class for all tick formatter types. TickFormatter is not
# generally useful to instantiate on its own.
TickFormatter <- R6::R6Class("TickFormatter",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Display horizontal or vertical grid lines at locations given by a
# supplied Ticker.
Grid <- R6::R6Class("Grid",
  inherit = GuideRenderer,
  public = list(
    initialize = function(
      plot = NA, level = "underlay", visible = TRUE,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, band_fill_alpha = list(value = 0L),
      band_fill_color = list(value = NULL), bounds = "auto", dimension = 0L,
      grid_line_alpha = list(value = 1), grid_line_cap = "butt",
      grid_line_color = list(value = "#e5e5e5"), grid_line_dash = list(),
      grid_line_dash_offset = 0L, grid_line_join = "miter",
      grid_line_width = list(value = 1L),
      minor_grid_line_alpha = list(value = 1),
      minor_grid_line_cap = "butt", minor_grid_line_color = list(value =
      NULL), minor_grid_line_dash = list(),
      minor_grid_line_dash_offset = 0L, minor_grid_line_join = "miter",
      minor_grid_line_width = list(value = 1L), ticker = NA,
      x_range_name = "default", y_range_name = "default"
    ) {
      super$initialize(plot = plot, level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$band_fill_alpha <- validate(band_fill_alpha, "NumberSpec")
      private$band_fill_color <- validate(band_fill_color, "ColorSpec")
      private$bounds <- validate(bounds, "Either ( Auto , Tuple ( Float , Float  ) )")
      private$dimension <- validate(dimension, "Int")
      private$grid_line_alpha <- validate(grid_line_alpha, "NumberSpec")
      private$grid_line_cap <- validate(grid_line_cap, "Enum ( LineCap  )")
      private$grid_line_color <- validate(grid_line_color, "ColorSpec")
      private$grid_line_dash <- validate(grid_line_dash, "DashPattern")
      private$grid_line_dash_offset <- validate(grid_line_dash_offset, "Int")
      private$grid_line_join <- validate(grid_line_join, "Enum ( LineJoin  )")
      private$grid_line_width <- validate(grid_line_width, "NumberSpec")
      private$minor_grid_line_alpha <- validate(minor_grid_line_alpha, "NumberSpec")
      private$minor_grid_line_cap <- validate(minor_grid_line_cap, "Enum ( LineCap  )")
      private$minor_grid_line_color <- validate(minor_grid_line_color, "ColorSpec")
      private$minor_grid_line_dash <- validate(minor_grid_line_dash, "DashPattern")
      private$minor_grid_line_dash_offset <- validate(minor_grid_line_dash_offset, "Int")
      private$minor_grid_line_join <- validate(minor_grid_line_join, "Enum ( LineJoin  )")
      private$minor_grid_line_width <- validate(minor_grid_line_width, "NumberSpec")
      private$ticker <- validate(ticker, "Instance ( Ticker  )")
      private$x_range_name <- validate(x_range_name, "String")
      private$y_range_name <- validate(y_range_name, "String")
    }
  ),
  private = list(
    # The fill alpha of alternating bands between Grid lines.
    band_fill_alpha = NULL, # NumberSpec
    # The fill color of alternating bands between Grid lines.
    band_fill_color = NULL, # ColorSpec
    # Bounds for the rendered grid lines. If unset, the grid lines will span
    # the entire plot in the given dimension.
    bounds = NULL, # Either ( Auto , Tuple ( Float , Float  ) )
    # Which dimension the Axis Grid lines will intersect. The x-axis is
    # dimension 0 (vertical Grid lines) and the y-axis is dimension 1
    # (horizontal Grid lines).
    dimension = NULL, # Int
    # The line alpha of the Grid lines.
    grid_line_alpha = NULL, # NumberSpec
    # The line cap of the Grid lines.
    grid_line_cap = NULL, # Enum ( LineCap  )
    # The line color of the Grid lines.
    grid_line_color = NULL, # ColorSpec
    # The line dash of the Grid lines.
    grid_line_dash = NULL, # DashPattern
    # The line dash offset of the Grid lines.
    grid_line_dash_offset = NULL, # Int
    # The line join of the Grid lines.
    grid_line_join = NULL, # Enum ( LineJoin  )
    # The line width of the Grid lines.
    grid_line_width = NULL, # NumberSpec
    # The line alpha of the minor Grid lines.
    minor_grid_line_alpha = NULL, # NumberSpec
    # The line cap of the minor Grid lines.
    minor_grid_line_cap = NULL, # Enum ( LineCap  )
    # The line color of the minor Grid lines.
    minor_grid_line_color = NULL, # ColorSpec
    # The line dash of the minor Grid lines.
    minor_grid_line_dash = NULL, # DashPattern
    # The line dash offset of the minor Grid lines.
    minor_grid_line_dash_offset = NULL, # Int
    # The line join of the minor Grid lines.
    minor_grid_line_join = NULL, # Enum ( LineJoin  )
    # The line width of the minor Grid lines.
    minor_grid_line_width = NULL, # NumberSpec
    # The Ticker to use for computing locations for the Grid lines.
    ticker = NULL, # Instance ( Ticker  )
    # A particular (named) x-range to use for computing screen locations when
    # rendering a grid on the plot. If unset, use the default x-range.
    x_range_name = NULL, # String
    # A particular (named) y-range to use for computing screen locations when
    # rendering a grid on the plot. If unset, use the default y-range.
    y_range_name = NULL # String
  )
)

# A base class for all image source types.
ImageSource <- R6::R6Class("ImageSource",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, extra_url_vars = structure(list(), .Names =
      character(0)), url = ""
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$extra_url_vars <- validate(extra_url_vars, "Dict ( String , Any  )")
      private$url <- validate(url, "String")
    }
  ),
  private = list(
    # A dictionary that maps url variable template keys to values. These
    # variables are useful for parts of tile urls which do not change from
    # tile to tile (e.g. server host name, or layer name).
    extra_url_vars = NULL, # Dict ( String , Any  )
    # tile service url (example:
    # http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png)
    url = NULL # String
  )
)

# Abstract base class for Row and Column. Do not use directly.
Box <- R6::R6Class("Box",
  inherit = LayoutDOM,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, children = list()
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$children <- validate(children, "List ( Instance ( LayoutDOM  ) )")
    }
  ),
  private = list(
    # The list of children, which can be other components including plots,
    # rows, columns, and widgets.
    children = NULL # List ( Instance ( LayoutDOM  ) )
  )
)

# Children can be specified as positional arguments, as a single argument
# that is a sequence, or using the children keyword argument.
Column <- R6::R6Class("Column",
  inherit = Box,
  public = list(
    initialize = function(
      children = list(), css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(children = children, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# An abstract base class for layout components. LayoutDOM is not
# generally useful to instantiate on its own.
LayoutDOM <- R6::R6Class("LayoutDOM",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$css_classes <- validate(css_classes, "Seq ( String  )")
      private$disabled <- validate(disabled, "Bool")
      private$height <- validate(height, "Int")
      private$sizing_mode <- validate(sizing_mode, "Enum ( SizingMode  )")
      private$width <- validate(width, "Int")
    }
  ),
  private = list(
    # A list of css class names to add to this DOM element. Note: the class
    # names are simply added as-is, no other guarantees are provided.
    css_classes = NULL, # Seq ( String  )
    # Whether the widget will be disabled when rendered. If True, the widget
    # will be greyed-out, and not respond to UI events.
    disabled = NULL, # Bool
    # An optional height for the component (in pixels).
    height = NULL, # Int
    # How the item being displayed should size itself. Possible values are
    # "fixed", "scale_width", "scale_height", "scale_both", and
    # "stretch_both". "stretch_both" elements are completely responsive
    # (independently in width and height) and will resize to occupy all
    # available space, even if this changes the aspect ratio of the element.
    # This is sometimes called outside-in, and is a typical behavior for
    # desktop applications. "fixed" elements are not responsive. They will
    # retain their original width and height regardless of any subsequent
    # browser window resize events. "scale_width" elements will responsively
    # resize to fit to the width available, while maintaining the original
    # aspect ratio. This is a typical behavior for modern websites. For a
    # Plot, the aspect ratio plot_width/plot_height is maintained.
    # "scale_height" elements will responsively resize to fit to the height
    # available, while maintaining the original aspect ratio. For a Plot, the
    # aspect ratio plot_width/plot_height is maintained. A plot with
    # "scale_height" mode needs to be wrapped in a Row or Column to be
    # responsive. "scale_both" elements will responsively resize to fir both
    # the width and height available, while maintaining the original aspect
    # ratio.
    sizing_mode = NULL, # Enum ( SizingMode  )
    # An optional width for the component (in pixels).
    width = NULL # Int
  )
)

# Children can be specified as positional arguments, as a single argument
# that is a sequence, or using the children keyword argument.
Row <- R6::R6Class("Row",
  inherit = Box,
  public = list(
    initialize = function(
      children = list(), css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(children = children, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# A container for space used to fill an empty spot in a row or column.
Spacer <- R6::R6Class("Spacer",
  inherit = LayoutDOM,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# A container for widgets that are part of a layout.
WidgetBox <- R6::R6Class("WidgetBox",
  inherit = LayoutDOM,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, children = list()
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$children <- validate(children, "List ( Instance ( Widget  ) )")
    }
  ),
  private = list(
    # The list of widgets to put in the layout box.
    children = NULL # List ( Instance ( Widget  ) )
  )
)

# Data placed on this plot should be specified in decimal lat long
# coordinates e.g. 37.123, -122.404. It will be automatically converted
# into the web mercator projection to display properly over google maps
# tiles.
GMapPlot <- R6::R6Class("GMapPlot",
  inherit = MapPlot,
  public = list(
    initialize = function(
      above = list(), background_fill_alpha = list(value = 1),
      background_fill_color = list(value = "#ffffff"), below = list(),
      border_fill_alpha = list(value = 1), border_fill_color = list(value =
      "#ffffff"), extra_x_ranges = structure(list(), .Names =
      character(0)), extra_y_ranges = structure(list(), .Names =
      character(0)), h_symmetry = TRUE, hidpi = TRUE, left = list(),
      lod_factor = 10L, lod_interval = 300L, lod_threshold = 2000L,
      lod_timeout = 500L, min_border = 5L, min_border_bottom = NA,
      min_border_left = NA, min_border_right = NA, min_border_top = NA,
      outline_line_alpha = list(value = 1), outline_line_cap = "butt",
      outline_line_color = list(value = "#e5e5e5"),
      outline_line_dash = list(), outline_line_dash_offset = 0L,
      outline_line_join = "miter", outline_line_width = list(value = 1L),
      plot_height = 600L, plot_width = 600L, renderers = list(),
      right = list(), title = list(id =
      "0ad75306-01df-464e-8834-7d8715bbc921", type = "Title"),
      title_location = "above", tool_events = NA, toolbar = NA,
      toolbar_location = "right", toolbar_sticky = TRUE, v_symmetry = FALSE,
      webgl = FALSE, x_mapper_type = "auto", x_range = NA,
      y_mapper_type = "auto", y_range = NA, css_classes = NA, disabled = FALSE,
      height = NA, sizing_mode = "fixed", width = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, api_key = NA, map_options = NA
    ) {
      super$initialize(above = above,
        background_fill_alpha = background_fill_alpha,
        background_fill_color = background_fill_color, below = below,
        border_fill_alpha = border_fill_alpha,
        border_fill_color = border_fill_color,
        extra_x_ranges = extra_x_ranges, extra_y_ranges = extra_y_ranges,
        h_symmetry = h_symmetry, hidpi = hidpi, left = left,
        lod_factor = lod_factor, lod_interval = lod_interval,
        lod_threshold = lod_threshold, lod_timeout = lod_timeout,
        min_border = min_border, min_border_bottom = min_border_bottom,
        min_border_left = min_border_left,
        min_border_right = min_border_right,
        min_border_top = min_border_top,
        outline_line_alpha = outline_line_alpha,
        outline_line_cap = outline_line_cap,
        outline_line_color = outline_line_color,
        outline_line_dash = outline_line_dash,
        outline_line_dash_offset = outline_line_dash_offset,
        outline_line_join = outline_line_join,
        outline_line_width = outline_line_width, plot_height = plot_height,
        plot_width = plot_width, renderers = renderers, right = right,
        title = title, title_location = title_location,
        tool_events = tool_events, toolbar = toolbar,
        toolbar_location = toolbar_location,
        toolbar_sticky = toolbar_sticky, v_symmetry = v_symmetry,
        webgl = webgl, x_mapper_type = x_mapper_type, x_range = x_range,
        y_mapper_type = y_mapper_type, y_range = y_range,
        css_classes = css_classes, disabled = disabled, height = height,
        sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$api_key <- validate(api_key, "String")
      private$map_options <- validate(map_options, "Instance ( GMapOptions  )")
    }
  ),
  private = list(
    # Google Maps API requires an API key. See
    # https://developers.google.com/maps/documentation/javascript/get-api-key
    # for more information on how to obtain your own.
    api_key = NULL, # String
    # Options for displaying the plot.
    map_options = NULL # Instance ( GMapOptions  )
  )
)

# Abstract base class for map plot models.
MapPlot <- R6::R6Class("MapPlot",
  inherit = Plot,
  public = list(
    initialize = function(
      above = list(), background_fill_alpha = list(value = 1),
      background_fill_color = list(value = "#ffffff"), below = list(),
      border_fill_alpha = list(value = 1), border_fill_color = list(value =
      "#ffffff"), extra_x_ranges = structure(list(), .Names =
      character(0)), extra_y_ranges = structure(list(), .Names =
      character(0)), h_symmetry = TRUE, hidpi = TRUE, left = list(),
      lod_factor = 10L, lod_interval = 300L, lod_threshold = 2000L,
      lod_timeout = 500L, min_border = 5L, min_border_bottom = NA,
      min_border_left = NA, min_border_right = NA, min_border_top = NA,
      outline_line_alpha = list(value = 1), outline_line_cap = "butt",
      outline_line_color = list(value = "#e5e5e5"),
      outline_line_dash = list(), outline_line_dash_offset = 0L,
      outline_line_join = "miter", outline_line_width = list(value = 1L),
      plot_height = 600L, plot_width = 600L, renderers = list(),
      right = list(), title = list(id =
      "985d4472-142e-45a8-89cd-9725d2d152ca", type = "Title"),
      title_location = "above", tool_events = NA, toolbar = NA,
      toolbar_location = "right", toolbar_sticky = TRUE, v_symmetry = FALSE,
      webgl = FALSE, x_mapper_type = "auto", x_range = NA,
      y_mapper_type = "auto", y_range = NA, css_classes = NA, disabled = FALSE,
      height = NA, sizing_mode = "fixed", width = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(above = above,
        background_fill_alpha = background_fill_alpha,
        background_fill_color = background_fill_color, below = below,
        border_fill_alpha = border_fill_alpha,
        border_fill_color = border_fill_color,
        extra_x_ranges = extra_x_ranges, extra_y_ranges = extra_y_ranges,
        h_symmetry = h_symmetry, hidpi = hidpi, left = left,
        lod_factor = lod_factor, lod_interval = lod_interval,
        lod_threshold = lod_threshold, lod_timeout = lod_timeout,
        min_border = min_border, min_border_bottom = min_border_bottom,
        min_border_left = min_border_left,
        min_border_right = min_border_right,
        min_border_top = min_border_top,
        outline_line_alpha = outline_line_alpha,
        outline_line_cap = outline_line_cap,
        outline_line_color = outline_line_color,
        outline_line_dash = outline_line_dash,
        outline_line_dash_offset = outline_line_dash_offset,
        outline_line_join = outline_line_join,
        outline_line_width = outline_line_width, plot_height = plot_height,
        plot_width = plot_width, renderers = renderers, right = right,
        title = title, title_location = title_location,
        tool_events = tool_events, toolbar = toolbar,
        toolbar_location = toolbar_location,
        toolbar_sticky = toolbar_sticky, v_symmetry = v_symmetry,
        webgl = webgl, x_mapper_type = x_mapper_type, x_range = x_range,
        y_mapper_type = y_mapper_type, y_range = y_range,
        css_classes = css_classes, disabled = disabled, height = height,
        sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Map categories to colors. Values that are passed to this mapper that
# aren’t in factors will be assigned the nan_color.
CategoricalColorMapper <- R6::R6Class("CategoricalColorMapper",
  inherit = ColorMapper,
  public = list(
    initialize = function(
      nan_color = "gray", palette = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, factors = NA
    ) {
      super$initialize(nan_color = nan_color, palette = palette,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$factors <- validate(factors, "Either ( Seq ( String  ), Seq ( Int  ), Seq ( Float  ), Seq ( Datetime  ), Seq ( Date  ) )")
    }
  ),
  private = list(
    # A sequence of factors / categories that map to the color palette.
    factors = NULL # Either ( Seq ( String  ), Seq ( Int  ), Seq ( Float  ), Seq ( Datetime  ), Seq ( Date  ) )
  )
)

# Base class for color mapper types. ColorMapper is not generally useful
# to instantiate on its own.
ColorMapper <- R6::R6Class("ColorMapper",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, nan_color = "gray", palette = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$nan_color <- validate(nan_color, "Color")
      private$palette <- validate(palette, "Seq ( Color  )")
    }
  ),
  private = list(
    # Color to be used if data is NaN. Default: ‘gray’
    nan_color = NULL, # Color
    # A sequence of colors to use as the target palette for mapping. This
    # property can also be set as a String, to the name of any of the
    # palettes shown in bokeh.palettes.
    palette = NULL # Seq ( Color  )
  )
)

# Base class for cotinuous color mapper types. ContinuousColorMapper is
# not generally useful to instantiate on its own.
ContinuousColorMapper <- R6::R6Class("ContinuousColorMapper",
  inherit = ColorMapper,
  public = list(
    initialize = function(
      nan_color = "gray", palette = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, high = NA,
      high_color = NA, low = NA, low_color = NA
    ) {
      super$initialize(nan_color = nan_color, palette = palette,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$high <- validate(high, "Float")
      private$high_color <- validate(high_color, "Color")
      private$low <- validate(low, "Float")
      private$low_color <- validate(low_color, "Color")
    }
  ),
  private = list(
    # The maximum value of the range to map into the palette. Values above
    # this are clamped to high.
    high = NULL, # Float
    # Color to be used if data is lower than high value. If None, values
    # lower than high are mapped to the last color in the palette.
    high_color = NULL, # Color
    # The minimum value of the range to map into the palette. Values below
    # this are clamped to low.
    low = NULL, # Float
    # Color to be used if data is lower than low value. If None, values lower
    # than low are mapped to the first color in the palette.
    low_color = NULL # Color
  )
)

# For example, if the range is [0, 99] and the palette is ['red',
# 'green', 'blue'], the values would be mapped as follows:
LinearColorMapper <- R6::R6Class("LinearColorMapper",
  inherit = ContinuousColorMapper,
  public = list(
    initialize = function(
      high = NA, high_color = NA, low = NA, low_color = NA, nan_color = "gray",
      palette = NA, js_callbacks = structure(list(), .Names =
      character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(high = high, high_color = high_color, low = low,
        low_color = low_color, nan_color = nan_color, palette = palette,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# For example, if the range is [0, 25] and the palette is ['red',
# 'green', 'blue'], the values would be mapped as follows:
LogColorMapper <- R6::R6Class("LogColorMapper",
  inherit = ContinuousColorMapper,
  public = list(
    initialize = function(
      high = NA, high_color = NA, low = NA, low_color = NA, nan_color = "gray",
      palette = NA, js_callbacks = structure(list(), .Names =
      character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(high = high, high_color = high_color, low = low,
        low_color = low_color, nan_color = nan_color, palette = palette,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Base class for all objects stored in Bokeh Document instances.
Model <- R6::R6Class("Model",
  inherit = Base,
  public = list(
    initialize = function(
      id = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list()
    ) {
      super$initialize(id = id)
      private$js_callbacks <- validate(js_callbacks, "Dict ( String , List ( Instance ( CustomJS  ) ) )")
      private$name <- validate(name, "String")
      private$tags <- validate(tags, "List ( Any  )")
    }
  ),
  private = list(
    # A mapping of attribute names to lists of CustomJS callbacks, to be set
    # up on BokehJS side when the document is created. Typically, rather then
    # modifying this property directly, callbacks should be added using the
    # Model.js_on_change method:
    js_callbacks = NULL, # Dict ( String , List ( Instance ( CustomJS  ) ) )
    # An arbitrary, user-supplied name for this model. This name can be
    # useful when querying the document to retrieve specific Bokeh models.
    name = NULL, # String
    # An optional list of arbitrary, user-supplied values to attach to this
    # model. This data can be useful when querying the document to retrieve
    # specific Bokeh models: Or simply a convenient way to attach any
    # necessary metadata to a model that can be accessed by CustomJS
    # callbacks, etc.
    tags = NULL # List ( Any  )
  )
)

# Model representing a plot, containing glyphs, guides, annotations.
Plot <- R6::R6Class("Plot",
  inherit = LayoutDOM,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, above = list(),
      background_fill_alpha = list(value = 1),
      background_fill_color = list(value = "#ffffff"), below = list(),
      border_fill_alpha = list(value = 1), border_fill_color = list(value =
      "#ffffff"), extra_x_ranges = structure(list(), .Names =
      character(0)), extra_y_ranges = structure(list(), .Names =
      character(0)), h_symmetry = TRUE, hidpi = TRUE, left = list(),
      lod_factor = 10L, lod_interval = 300L, lod_threshold = 2000L,
      lod_timeout = 500L, min_border = 5L, min_border_bottom = NA,
      min_border_left = NA, min_border_right = NA, min_border_top = NA,
      outline_line_alpha = list(value = 1), outline_line_cap = "butt",
      outline_line_color = list(value = "#e5e5e5"),
      outline_line_dash = list(), outline_line_dash_offset = 0L,
      outline_line_join = "miter", outline_line_width = list(value = 1L),
      plot_height = 600L, plot_width = 600L, renderers = list(),
      right = list(), title = list(id =
      "e0831177-9fc9-4ab8-a385-fac5a1584399", type = "Title"),
      title_location = "above", tool_events = NA, toolbar = NA,
      toolbar_location = "right", toolbar_sticky = TRUE, v_symmetry = FALSE,
      webgl = FALSE, x_mapper_type = "auto", x_range = NA,
      y_mapper_type = "auto", y_range = NA
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$above <- validate(above, "List ( Instance ( Renderer  ) )")
      private$background_fill_alpha <- validate(background_fill_alpha, "NumberSpec")
      private$background_fill_color <- validate(background_fill_color, "ColorSpec")
      private$below <- validate(below, "List ( Instance ( Renderer  ) )")
      private$border_fill_alpha <- validate(border_fill_alpha, "NumberSpec")
      private$border_fill_color <- validate(border_fill_color, "ColorSpec")
      private$extra_x_ranges <- validate(extra_x_ranges, "Dict ( String , Instance ( Range  ) )")
      private$extra_y_ranges <- validate(extra_y_ranges, "Dict ( String , Instance ( Range  ) )")
      private$h_symmetry <- validate(h_symmetry, "Bool")
      private$hidpi <- validate(hidpi, "Bool")
      private$left <- validate(left, "List ( Instance ( Renderer  ) )")
      private$lod_factor <- validate(lod_factor, "Int")
      private$lod_interval <- validate(lod_interval, "Int")
      private$lod_threshold <- validate(lod_threshold, "Int")
      private$lod_timeout <- validate(lod_timeout, "Int")
      private$min_border <- validate(min_border, "Int")
      private$min_border_bottom <- validate(min_border_bottom, "Int")
      private$min_border_left <- validate(min_border_left, "Int")
      private$min_border_right <- validate(min_border_right, "Int")
      private$min_border_top <- validate(min_border_top, "Int")
      private$outline_line_alpha <- validate(outline_line_alpha, "NumberSpec")
      private$outline_line_cap <- validate(outline_line_cap, "Enum ( LineCap  )")
      private$outline_line_color <- validate(outline_line_color, "ColorSpec")
      private$outline_line_dash <- validate(outline_line_dash, "DashPattern")
      private$outline_line_dash_offset <- validate(outline_line_dash_offset, "Int")
      private$outline_line_join <- validate(outline_line_join, "Enum ( LineJoin  )")
      private$outline_line_width <- validate(outline_line_width, "NumberSpec")
      private$plot_height <- validate(plot_height, "Int")
      private$plot_width <- validate(plot_width, "Int")
      private$renderers <- validate(renderers, "List ( Instance ( Renderer  ) )")
      private$right <- validate(right, "List ( Instance ( Renderer  ) )")
      private$title <- validate(title, "TitleProp")
      private$title_location <- validate(title_location, "Enum ( Location  )")
      private$tool_events <- validate(tool_events, "Instance ( ToolEvents  )")
      private$toolbar <- validate(toolbar, "Instance ( Toolbar  )")
      private$toolbar_location <- validate(toolbar_location, "Enum ( Location  )")
      private$toolbar_sticky <- validate(toolbar_sticky, "Bool")
      private$v_symmetry <- validate(v_symmetry, "Bool")
      private$webgl <- validate(webgl, "Bool")
      private$x_mapper_type <- validate(x_mapper_type, "Either ( Auto , String  )")
      private$x_range <- validate(x_range, "Instance ( Range  )")
      private$y_mapper_type <- validate(y_mapper_type, "Either ( Auto , String  )")
      private$y_range <- validate(y_range, "Instance ( Range  )")
    }
  ),
  private = list(
    # A list of renderers to occupy the area above of the plot.
    above = NULL, # List ( Instance ( Renderer  ) )
    # The fill alpha for the plot background style.
    background_fill_alpha = NULL, # NumberSpec
    # The fill color for the plot background style.
    background_fill_color = NULL, # ColorSpec
    # A list of renderers to occupy the area below of the plot.
    below = NULL, # List ( Instance ( Renderer  ) )
    # The fill alpha for the plot border style.
    border_fill_alpha = NULL, # NumberSpec
    # The fill color for the plot border style.
    border_fill_color = NULL, # ColorSpec
    # Additional named ranges to make available for mapping x-coordinates.
    # This is useful for adding additional axes.
    extra_x_ranges = NULL, # Dict ( String , Instance ( Range  ) )
    # Additional named ranges to make available for mapping y-coordinates.
    # This is useful for adding additional axes.
    extra_y_ranges = NULL, # Dict ( String , Instance ( Range  ) )
    # Whether the total horizontal padding on both sides of the plot will be
    # made equal (the left or right padding amount, whichever is larger).
    h_symmetry = NULL, # Bool
    # Whether to use HiDPI mode when available.
    hidpi = NULL, # Bool
    # A list of renderers to occupy the area to the left of the plot.
    left = NULL, # List ( Instance ( Renderer  ) )
    # Decimation factor to use when applying level-of-detail decimation.
    lod_factor = NULL, # Int
    # Interval (in ms) during which an interactive tool event will enable
    # level-of-detail downsampling.
    lod_interval = NULL, # Int
    # A number of data points, above which level-of-detail downsampling may
    # be performed by glyph renderers. Set to None to disable any
    # level-of-detail downsampling.
    lod_threshold = NULL, # Int
    # Timeout (in ms) for checking whether interactive tool events are still
    # occurring. Once level-of-detail mode is enabled, a check is made every
    # lod_timeout ms. If no interactive tool events have happened,
    # level-of-detail mode is disabled.
    lod_timeout = NULL, # Int
    # A convenience property to set all all the min_border_X properties to
    # the same value. If an individual border property is explicitly set, it
    # will override min_border.
    min_border = NULL, # Int
    # Minimum size in pixels of the padding region below the bottom of the
    # central plot region.
    min_border_bottom = NULL, # Int
    # Minimum size in pixels of the padding region to the left of the central
    # plot region.
    min_border_left = NULL, # Int
    # Minimum size in pixels of the padding region to the right of the
    # central plot region.
    min_border_right = NULL, # Int
    # Minimum size in pixels of the padding region above the top of the
    # central plot region.
    min_border_top = NULL, # Int
    # The line alpha for the plot border outline.
    outline_line_alpha = NULL, # NumberSpec
    # The line cap for the plot border outline.
    outline_line_cap = NULL, # Enum ( LineCap  )
    # The line color for the plot border outline.
    outline_line_color = NULL, # ColorSpec
    # The line dash for the plot border outline.
    outline_line_dash = NULL, # DashPattern
    # The line dash offset for the plot border outline.
    outline_line_dash_offset = NULL, # Int
    # The line join for the plot border outline.
    outline_line_join = NULL, # Enum ( LineJoin  )
    # The line width for the plot border outline.
    outline_line_width = NULL, # NumberSpec
    # Total height of the entire plot (including any axes, titles, border
    # padding, etc.)
    plot_height = NULL, # Int
    # Total width of the entire plot (including any axes, titles, border
    # padding, etc.)
    plot_width = NULL, # Int
    # A list of all renderers for this plot, including guides and annotations
    # in addition to glyphs and markers. This property can be manipulated by
    # hand, but the add_glyph and add_layout methods are recommended to help
    # make sure all necessary setup is performed.
    renderers = NULL, # List ( Instance ( Renderer  ) )
    # A list of renderers to occupy the area to the right of the plot.
    right = NULL, # List ( Instance ( Renderer  ) )
    # A title for the plot. Can be a text string or a Title annotation.
    # Default is Title(text=””).
    title = NULL, # TitleProp
    # Where the title will be located. Titles on the left or right side will
    # be rotated.
    title_location = NULL, # Enum ( Location  )
    # A ToolEvents object to share and report tool events.
    tool_events = NULL, # Instance ( ToolEvents  )
    # The toolbar associated with this plot which holds all the tools. The
    # toolbar is automatically created with the plot.
    toolbar = NULL, # Instance ( Toolbar  )
    # Where the toolbar will be located. If set to None, no toolbar will be
    # attached to the plot.
    toolbar_location = NULL, # Enum ( Location  )
    # Stick the toolbar to the edge of the plot. Default: True. If False, the
    # toolbar will be outside of the axes, titles etc.
    toolbar_sticky = NULL, # Bool
    # Whether the total vertical padding on both sides of the plot will be
    # made equal (the top or bottom padding amount, whichever is larger).
    v_symmetry = NULL, # Bool
    # Whether WebGL is enabled for this plot. If True, the glyphs that
    # support this will render via WebGL instead of the 2D canvas.
    webgl = NULL, # Bool
    # What kind of mapper to use to convert x-coordinates in data space into
    # x-coordinates in screen space. Typically this can be determined
    # automatically, but this property can be useful to, e.g., show datetime
    # values as floating point “seconds since epoch” instead of formatted
    # dates.
    x_mapper_type = NULL, # Either ( Auto , String  )
    # The (default) data range of the horizontal dimension of the plot.
    x_range = NULL, # Instance ( Range  )
    # What kind of mapper to use to convert y-coordinates in data space into
    # y-coordinates in screen space. Typically this can be determined
    # automatically, but this property can be useful to, e.g., show datetime
    # values as floating point “seconds since epoch” instead of formatted
    # dates
    y_mapper_type = NULL, # Either ( Auto , String  )
    # The (default) data range of the vertical dimension of the plot.
    y_range = NULL # Instance ( Range  )
  )
)

# A base class for all data range types. DataRange is not generally
# useful to instantiate on its own.
DataRange <- R6::R6Class("DataRange",
  inherit = Range,
  public = list(
    initialize = function(
      callback = NA, js_callbacks = structure(list(), .Names =
      character(0)), name = NA, tags = list(), id = NA, names = list(),
      renderers = list()
    ) {
      super$initialize(callback = callback, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$names <- validate(names, "List ( String  )")
      private$renderers <- validate(renderers, "List ( Instance ( Renderer  ) )")
    }
  ),
  private = list(
    # A list of names to query for. If set, only renderers that have a
    # matching value for their name attribute will be used for autoranging.
    names = NULL, # List ( String  )
    # An explicit list of renderers to autorange against. If unset, defaults
    # to all renderers on a plot.
    renderers = NULL # List ( Instance ( Renderer  ) )
  )
)

# An auto-fitting range in a continuous scalar dimension. The upper and
# lower bounds are set to the min and max of the data.
DataRange1d <- R6::R6Class("DataRange1d",
  inherit = DataRange,
  public = list(
    initialize = function(
      names = list(), renderers = list(), callback = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, bounds = NA, default_span = 2, end = NA,
      flipped = FALSE, follow = NA, follow_interval = NA, max_interval = NA,
      min_interval = NA, range_padding = 0.1, start = NA
    ) {
      super$initialize(names = names, renderers = renderers,
        callback = callback, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$bounds <- validate(bounds, "MinMaxBounds")
      private$default_span <- validate(default_span, "Float")
      private$end <- validate(end, "Float")
      private$flipped <- validate(flipped, "Bool")
      private$follow <- validate(follow, "Enum ( StartEnd  )")
      private$follow_interval <- validate(follow_interval, "Float")
      private$max_interval <- validate(max_interval, "Float")
      private$min_interval <- validate(min_interval, "Float")
      private$range_padding <- validate(range_padding, "Float")
      private$start <- validate(start, "Float")
    }
  ),
  private = list(
    # The bounds that the range is allowed to go to - typically used to
    # prevent the user from panning/zooming/etc away from the data. By
    # default, the bounds will be None, allowing your plot to pan/zoom as far
    # as you want. If bounds are ‘auto’ they will be computed to be the same
    # as the start and end of the DataRange1d. Bounds are provided as a tuple
    # of (min, max) so regardless of whether your range is increasing or
    # decreasing, the first item should be the minimum value of the range and
    # the second item should be the maximum. Setting min > max will result in
    # a ValueError. If you only want to constrain one end of the plot, you
    # can set min or max to None e.g. DataRange1d(bounds=(None, 12))
    bounds = NULL, # MinMaxBounds
    # A default width for the interval, in case start is equal to end (if
    # used with a log axis, default_span is in powers of 10).
    default_span = NULL, # Float
    # An explicitly supplied range end. If provided, will override
    # automatically computed end value.
    end = NULL, # Float
    # Whether the range should be “flipped” from its normal direction when
    # auto-ranging.
    flipped = NULL, # Bool
    # Configure the data to follow one or the other data extreme, with a
    # maximum range size of follow_interval. If set to "start" then the range
    # will adjust so that start always corresponds to the minimum data value
    # (or maximum, if flipped is True). If set to "end" then the range will
    # adjust so that end always corresponds to the maximum data value (or
    # minimum, if flipped is True). If set to None (default), then
    # auto-ranging does not follow, and the range will encompass both the
    # minimum and maximum data values. follow cannot be used with bounds, and
    # if set, bounds will be set to None.
    follow = NULL, # Enum ( StartEnd  )
    # If follow is set to "start" or "end" then the range will always be
    # constrained to that: is maintained.
    follow_interval = NULL, # Float
    # The level that the range is allowed to zoom out, expressed as the
    # maximum visible interval. Note that bounds can impose an implicit
    # constraint on the maximum interval as well.
    max_interval = NULL, # Float
    # The level that the range is allowed to zoom in, expressed as the
    # minimum visible interval. If set to None (default), the minimum
    # interval is not bound.
    min_interval = NULL, # Float
    # A fraction of the total range size to add as padding to the range start
    # and end.
    range_padding = NULL, # Float
    # An explicitly supplied range start. If provided, will override
    # automatically computed start value.
    start = NULL # Float
  )
)

# In addition to supplying factors keyword argument to the FactorRange
# initializer, you can also instantiate with the convenience syntax:
FactorRange <- R6::R6Class("FactorRange",
  inherit = Range,
  public = list(
    initialize = function(
      callback = NA, js_callbacks = structure(list(), .Names =
      character(0)), name = NA, tags = list(), id = NA, bounds = NA,
      factors = list(), max_interval = NA, min_interval = NA, offset = 0L
    ) {
      super$initialize(callback = callback, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$bounds <- validate(bounds, "Either ( Auto , List ( String  ), List ( Int  ) )")
      private$factors <- validate(factors, "Either ( List ( String  ), List ( Int  ) )")
      private$max_interval <- validate(max_interval, "Int")
      private$min_interval <- validate(min_interval, "Int")
      private$offset <- validate(offset, "Float")
    }
  ),
  private = list(
    # The bounds that the range is allowed to go to - typically used to
    # prevent the user from panning/zooming/etc away from the data. Unlike
    # Range1d and DataRange1d, factors do not have an order and so a min and
    # max cannot be provied in the same way. bounds accepts a list of
    # factors, that constrain the displayed factors. By default, bounds are
    # None, allows unlimited panning or zooming. If bounds='auto', bounds
    # will be the same as factors and the plot will not be able to pan or
    # zoom beyond the first and last items in factors. If you provide a list,
    # then only the factors that are in that list will be displayed on the
    # plot and the plot will not pan or zoom outside the first and last items
    # in the shortened factors list. Note the order of factors is the
    # defining order for your plot. Values of bounds that are not in factors
    # are acceptable and will simply have no impact on the plot. Examples:
    # x_range = FactorRange(factors=[“apples”, “dogs”, “peaches”, “bananas”,
    # “pigs”], bounds=’auto’) The plot will display all the factors and you
    # will not be able to pan left of apples or right of pigs. x_range =
    # FactorRange(factors=[“apples”, “dogs”, “peaches”, “bananas”, “pigs”],
    # bounds=[“apples”, “bananas”, “peaches”]) The plot will display the
    # chart with only the factors [“apples”, “peaches”, “bananas”] (in that
    # order) and the plot will not pan left of apples or right of bananas.
    bounds = NULL, # Either ( Auto , List ( String  ), List ( Int  ) )
    # A list of string or integer factors (categories) to comprise this
    # categorical range.
    factors = NULL, # Either ( List ( String  ), List ( Int  ) )
    # The level that the range is allowed to zoom out, expressed as the
    # maximum number of visible categories. Note that bounds can impose an
    # implicit constraint on the maximum interval as well.
    max_interval = NULL, # Int
    # The level that the range is allowed to zoom in, expressed as the
    # minimum number of visible categories. If set to None (default), the
    # minimum interval is not bound.
    min_interval = NULL, # Int
    # An offset to the (synthetic) range (default: 0)
    offset = NULL # Float
  )
)

# A base class for all range types. Range is not generally useful to
# instantiate on its own.
Range <- R6::R6Class("Range",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, callback = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
    }
  ),
  private = list(
    # A callback to run in the browser whenever the range is updated.
    callback = NULL # Instance ( Callback  )
  )
)

# In addition to supplying start and end keyword arguments to the Range1d
# initializer, you can also instantiate with the convenience syntax:
Range1d <- R6::R6Class("Range1d",
  inherit = Range,
  public = list(
    initialize = function(
      callback = NA, js_callbacks = structure(list(), .Names =
      character(0)), name = NA, tags = list(), id = NA, bounds = NA, end = 1L,
      max_interval = NA, min_interval = NA, start = 0L
    ) {
      super$initialize(callback = callback, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$bounds <- validate(bounds, "MinMaxBounds")
      private$end <- validate(end, "Either ( Float , Datetime , Int  )")
      private$max_interval <- validate(max_interval, "Either ( Float , TimeDelta , Int  )")
      private$min_interval <- validate(min_interval, "Either ( Float , TimeDelta , Int  )")
      private$start <- validate(start, "Either ( Float , Datetime , Int  )")
    }
  ),
  private = list(
    # The bounds that the range is allowed to go to - typically used to
    # prevent the user from panning/zooming/etc away from the data. If set to
    # 'auto', the bounds will be computed to the start and end of the Range.
    # Bounds are provided as a tuple of (min, max) so regardless of whether
    # your range is increasing or decreasing, the first item should be the
    # minimum value of the range and the second item should be the maximum.
    # Setting min > max will result in a ValueError. By default, bounds are
    # None and your plot to pan/zoom as far as you want. If you only want to
    # constrain one end of the plot, you can set min or max to None.
    # Examples:
    bounds = NULL, # MinMaxBounds
    # The end of the range.
    end = NULL, # Either ( Float , Datetime , Int  )
    # The level that the range is allowed to zoom out, expressed as the
    # maximum visible interval. Can be a timedelta. Note that bounds can
    # impose an implicit constraint on the maximum interval as well.
    max_interval = NULL, # Either ( Float , TimeDelta , Int  )
    # The level that the range is allowed to zoom in, expressed as the
    # minimum visible interval. If set to None (default), the minimum
    # interval is not bound. Can be a timedelta.
    min_interval = NULL, # Either ( Float , TimeDelta , Int  )
    # The start of the range.
    start = NULL # Either ( Float , Datetime , Int  )
  )
)

# An abstract base class for data renderer types (e.g. GlyphRenderer,
# TileRenderer).
DataRenderer <- R6::R6Class("DataRenderer",
  inherit = Renderer,
  public = list(
    initialize = function(
      level = "image", visible = TRUE, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Bases: bokeh.models.renderers.DataRenderer
DynamicImageRenderer <- R6::R6Class("DynamicImageRenderer",
  inherit = DataRenderer,
  public = list(
    initialize = function(
      level = "underlay", visible = TRUE, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, alpha = 1,
      image_source = NA, render_parents = TRUE
    ) {
      super$initialize(level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$alpha <- validate(alpha, "Float")
      private$image_source <- validate(image_source, "Instance ( ImageSource  )")
      private$render_parents <- validate(render_parents, "Bool")
    }
  ),
  private = list(
    # tile opacity 0.0 - 1.0
    alpha = NULL, # Float
    # Image source to use when rendering on the plot.
    image_source = NULL, # Instance ( ImageSource  )
    # Flag enable/disable drawing of parent tiles while waiting for new tiles
    # to arrive. Default value is True.
    render_parents = NULL # Bool
  )
)

# Bases: bokeh.models.renderers.DataRenderer
GlyphRenderer <- R6::R6Class("GlyphRenderer",
  inherit = DataRenderer,
  public = list(
    initialize = function(
      level = "glyph", visible = TRUE, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA,
      data_source = NA, glyph = NA, hover_glyph = NA, nonselection_glyph = NA,
      selection_glyph = NA, x_range_name = "default",
      y_range_name = "default"
    ) {
      super$initialize(level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$data_source <- validate(data_source, "Instance ( DataSource  )")
      private$glyph <- validate(glyph, "Instance ( Glyph  )")
      private$hover_glyph <- validate(hover_glyph, "Instance ( Glyph  )")
      private$nonselection_glyph <- validate(nonselection_glyph, "Instance ( Glyph  )")
      private$selection_glyph <- validate(selection_glyph, "Instance ( Glyph  )")
      private$x_range_name <- validate(x_range_name, "String")
      private$y_range_name <- validate(y_range_name, "String")
    }
  ),
  private = list(
    # Local data source to use when rendering glyphs on the plot.
    data_source = NULL, # Instance ( DataSource  )
    # The glyph to render, in conjunction with the supplied data source and
    # ranges.
    glyph = NULL, # Instance ( Glyph  )
    # An optional glyph used for inspected points, e.g., those that are being
    # hovered over by a HoverTool.
    hover_glyph = NULL, # Instance ( Glyph  )
    # An optional glyph used for explicitly non-selected points (i.e.,
    # non-selected when there are other points that are selected, but not
    # when no points at all are selected.)
    nonselection_glyph = NULL, # Instance ( Glyph  )
    # An optional glyph used for selected points.
    selection_glyph = NULL, # Instance ( Glyph  )
    # A particular (named) x-range to use for computing screen locations when
    # rendering glyphs on the plot. If unset, use the default x-range.
    x_range_name = NULL, # String
    # A particular (named) y-range to use for computing screen locations when
    # rendering glyphs on the plot. If unset, use the default -range.
    y_range_name = NULL # String
  )
)

# A base class for all guide renderer types. GuideRenderer is not
# generally useful to instantiate on its own.
GuideRenderer <- R6::R6Class("GuideRenderer",
  inherit = Renderer,
  public = list(
    initialize = function(
      level = "overlay", visible = TRUE, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, plot = NA
    ) {
      super$initialize(level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$plot <- validate(plot, "Instance ( Plot  )")
    }
  ),
  private = list(
    # The plot to which this guide renderer is attached.
    plot = NULL # Instance ( Plot  )
  )
)

# An abstract base class for renderer types.
Renderer <- R6::R6Class("Renderer",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, level = "image", visible = TRUE
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$level <- validate(level, "Enum ( RenderLevel  )")
      private$visible <- validate(visible, "Bool")
    }
  ),
  private = list(
    # Specifies the level in which to paint this renderer.
    level = NULL, # Enum ( RenderLevel  )
    # Is the renderer visible. Default: True
    visible = NULL # Bool
  )
)

# Bases: bokeh.models.renderers.DataRenderer
TileRenderer <- R6::R6Class("TileRenderer",
  inherit = DataRenderer,
  public = list(
    initialize = function(
      level = "underlay", visible = TRUE, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, alpha = 1,
      render_parents = TRUE, tile_source = NA, x_range_name = "default",
      y_range_name = "default"
    ) {
      super$initialize(level = level, visible = visible,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$alpha <- validate(alpha, "Float")
      private$render_parents <- validate(render_parents, "Bool")
      private$tile_source <- validate(tile_source, "Instance ( TileSource  )")
      private$x_range_name <- validate(x_range_name, "String")
      private$y_range_name <- validate(y_range_name, "String")
    }
  ),
  private = list(
    # tile opacity 0.0 - 1.0
    alpha = NULL, # Float
    # Flag enable/disable drawing of parent tiles while waiting for new tiles
    # to arrive. Default value is True.
    render_parents = NULL, # Bool
    # Local data source to use when rendering glyphs on the plot.
    tile_source = NULL, # Instance ( TileSource  )
    # A particular (named) x-range to use for computing screen locations when
    # rendering glyphs on the plot. If unset, use the default x-range.
    x_range_name = NULL, # String
    # A particular (named) y-range to use for computing screen locations when
    # rendering glyphs on the plot. If unset, use the default y-range.
    y_range_name = NULL # String
  )
)

# Bases: bokeh.models.sources.RemoteSource
AjaxDataSource <- R6::R6Class("AjaxDataSource",
  inherit = RemoteSource,
  public = list(
    initialize = function(
      data_url = NA, polling_interval = NA, data = structure(list(), .Names =
      character(0)), column_names = list(), callback = NA,
      selected = structure(list(`0d` = structure(list(glyph = NULL,
      indices = list()), .Names = c("glyph", "indices")), `1d` =
      structure(list(indices = list()), .Names = "indices"), `2d` =
      structure(list(), .Names = character(0))), .Names = c("0d", "1d",
      "2d")), js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, content_type = "application/json",
      http_headers = structure(list(), .Names = character(0)),
      if_modified = FALSE, max_size = NA, method = "POST", mode = "replace"
    ) {
      super$initialize(data_url = data_url,
        polling_interval = polling_interval, data = data,
        column_names = column_names, callback = callback,
        selected = selected, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$content_type <- validate(content_type, "String")
      private$http_headers <- validate(http_headers, "Dict ( String , String  )")
      private$if_modified <- validate(if_modified, "Bool")
      private$max_size <- validate(max_size, "Int")
      private$method <- validate(method, "Enum ( Enumeration(POST, GET) )")
      private$mode <- validate(mode, "Enum ( Enumeration(replace, append) )")
    }
  ),
  private = list(
    # Set the “contentType” parameter for the Ajax request.
    content_type = NULL, # String
    # HTTP headers to set for the Ajax request.
    http_headers = NULL, # Dict ( String , String  )
    # Whether to include an If-Modified-Since header in AJAX requests to the
    # server. If this header is supported by the server, then only new data
    # since the last request will be returned.
    if_modified = NULL, # Bool
    # Maximum size of the data array being kept after each pull requests.
    # Larger than that size, the data will be right shifted.
    max_size = NULL, # Int
    # http method - GET or POST
    method = NULL, # Enum ( Enumeration(POST, GET) )
    # Whether to append new data to existing data (up to max_size), or to
    # replace existing data entirely.
    mode = NULL # Enum ( Enumeration(replace, append) )
  )
)

# If the ColumnDataSource initializer is called with a single argument
# that is a dict or pandas.DataFrame, that argument is used as the value
# for the “data” attribute. For example:
ColumnDataSource <- R6::R6Class("ColumnDataSource",
  inherit = ColumnarDataSource,
  public = list(
    initialize = function(
      column_names = list(), callback = NA, selected = structure(list(`0d` =
      structure(list(glyph = NULL, indices = list()), .Names =
      c("glyph", "indices")), `1d` = structure(list(indices = list()),
      .Names = "indices"), `2d` = structure(list(), .Names =
      character(0))), .Names = c("0d", "1d", "2d")),
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, data = structure(list(), .Names = character(0))
    ) {
      super$initialize(column_names = column_names, callback = callback,
        selected = selected, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$data <- validate(data, "ColumnData ( String , Seq ( Any  ) )")
    }
  ),
  private = list(
    # Mapping of column names to sequences of data. The data can be, e.g,
    # Python lists or tuples, NumPy arrays, etc.
    data = NULL # ColumnData ( String , Seq ( Any  ) )
  )
)

# A baseclass for data source types, which can be mapped onto a columnar
# format. Not useful to instantiate on its own.
ColumnarDataSource <- R6::R6Class("ColumnarDataSource",
  inherit = DataSource,
  public = list(
    initialize = function(
      callback = NA, selected = structure(list(`0d` = structure(list(glyph
      = NULL, indices = list()), .Names = c("glyph", "indices")), `1d`
      = structure(list(indices = list()), .Names = "indices"), `2d` =
      structure(list(), .Names = character(0))), .Names = c("0d", "1d",
      "2d")), js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, column_names = list()
    ) {
      super$initialize(callback = callback, selected = selected,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$column_names <- validate(column_names, "List ( String  )")
    }
  ),
  private = list(
    # An list of names for all the columns in this DataSource.
    column_names = NULL # List ( String  )
  )
)

# A base class for data source types. DataSource is not generally useful
# to instantiate on its own.
DataSource <- R6::R6Class("DataSource",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, callback = NA, selected = structure(list(`0d` =
      structure(list(glyph = NULL, indices = list()), .Names =
      c("glyph", "indices")), `1d` = structure(list(indices = list()),
      .Names = "indices"), `2d` = structure(list(), .Names =
      character(0))), .Names = c("0d", "1d", "2d"))
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$selected <- validate(selected, "Dict ( String , Dict ( String , Any  ) )")
    }
  ),
  private = list(
    # A callback to run in the browser whenever the selection is changed.
    callback = NULL, # Instance ( Callback  )
    # A dict to indicate selected indices on different dimensions on this
    # DataSource. Keys are: dict with the following keys: patches) was hit:
    # hit/selected
    selected = NULL # Dict ( String , Dict ( String , Any  ) )
  )
)

# Bases: bokeh.models.sources.ColumnarDataSource
GeoJSONDataSource <- R6::R6Class("GeoJSONDataSource",
  inherit = ColumnarDataSource,
  public = list(
    initialize = function(
      column_names = list(), callback = NA, selected = structure(list(`0d` =
      structure(list(glyph = NULL, indices = list()), .Names =
      c("glyph", "indices")), `1d` = structure(list(indices = list()),
      .Names = "indices"), `2d` = structure(list(), .Names =
      character(0))), .Names = c("0d", "1d", "2d")),
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, geojson = NA
    ) {
      super$initialize(column_names = column_names, callback = callback,
        selected = selected, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$geojson <- validate(geojson, "JSON")
    }
  ),
  private = list(
    # GeoJSON that contains features for plotting. Currently
    # GeoJSONDataSource can only process a FeatureCollection or
    # GeometryCollection.
    geojson = NULL # JSON
  )
)

# Bases: bokeh.models.sources.ColumnDataSource
RemoteSource <- R6::R6Class("RemoteSource",
  inherit = ColumnDataSource,
  public = list(
    initialize = function(
      data = structure(list(), .Names = character(0)),
      column_names = list(), callback = NA, selected = structure(list(`0d` =
      structure(list(glyph = NULL, indices = list()), .Names =
      c("glyph", "indices")), `1d` = structure(list(indices = list()),
      .Names = "indices"), `2d` = structure(list(), .Names =
      character(0))), .Names = c("0d", "1d", "2d")),
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, data_url = NA, polling_interval = NA
    ) {
      super$initialize(data = data, column_names = column_names,
        callback = callback, selected = selected,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$data_url <- validate(data_url, "String")
      private$polling_interval <- validate(polling_interval, "Int")
    }
  ),
  private = list(
    # The URL to the endpoint for the data.
    data_url = NULL, # String
    # polling interval for updating data source in milliseconds
    polling_interval = NULL # Int
  )
)

# Creates ticks that are “base” multiples of a set of given mantissas.
# For example, with base=10 and mantissas=[1, 2, 5], the ticker will
# generate the sequence:
AdaptiveTicker <- R6::R6Class("AdaptiveTicker",
  inherit = ContinuousTicker,
  public = list(
    initialize = function(
      desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, base = 10, mantissas = c(1L, 2L, 5L),
      max_interval = NA, min_interval = 0
    ) {
      super$initialize(desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$base <- validate(base, "Float")
      private$mantissas <- validate(mantissas, "Seq ( Float  )")
      private$max_interval <- validate(max_interval, "Float")
      private$min_interval <- validate(min_interval, "Float")
    }
  ),
  private = list(
    # The multiplier to use for scaling mantissas.
    base = NULL, # Float
    # The acceptable list numbers to generate multiples of.
    mantissas = NULL, # Seq ( Float  )
    # The largest allowable interval between two adjacent ticks.
    max_interval = NULL, # Float
    # The smallest allowable interval between two adjacent ticks.
    min_interval = NULL # Float
  )
)

# Generate ticks on a linear scale.
BasicTicker <- R6::R6Class("BasicTicker",
  inherit = AdaptiveTicker,
  public = list(
    initialize = function(
      base = 10, mantissas = c(1L, 2L, 5L), max_interval = NA,
      min_interval = 0, desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(base = base, mantissas = mantissas,
        max_interval = max_interval, min_interval = min_interval,
        desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Generate ticks for categorical ranges.
CategoricalTicker <- R6::R6Class("CategoricalTicker",
  inherit = Ticker,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Uses the min_interval and max_interval interval attributes of the
# tickers to select the appropriate ticker at different scales.
CompositeTicker <- R6::R6Class("CompositeTicker",
  inherit = ContinuousTicker,
  public = list(
    initialize = function(
      desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, tickers = list()
    ) {
      super$initialize(desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$tickers <- validate(tickers, "Seq ( Instance ( Ticker  ) )")
    }
  ),
  private = list(
    # A list of Ticker objects to combine at different scales in order to
    # generate tick values. The supplied tickers should be in order.
    # Specifically, if S comes before T, then it should be the case that:
    tickers = NULL # Seq ( Instance ( Ticker  ) )
  )
)

# A base class for non-categorical ticker types. ContinuousTicker is not
# generally useful to instantiate on its own.
ContinuousTicker <- R6::R6Class("ContinuousTicker",
  inherit = Ticker,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, desired_num_ticks = 6L, num_minor_ticks = 5L
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$desired_num_ticks <- validate(desired_num_ticks, "Int")
      private$num_minor_ticks <- validate(num_minor_ticks, "Int")
    }
  ),
  private = list(
    # A desired target number of major tick positions to generate across the
    # plot range.
    desired_num_ticks = NULL, # Int
    # The number of minor tick positions to generate between adjacent major
    # tick values.
    num_minor_ticks = NULL # Int
  )
)

# Generate nice ticks across different date and time scales.
DatetimeTicker <- R6::R6Class("DatetimeTicker",
  inherit = CompositeTicker,
  public = list(
    initialize = function(
      tickers = list(id = c("e13dfec1-f2a9-4766-bed3-4f0b3b29d7b7",
      "d3fc30f9-203e-479d-8882-155145484a09",
      "ebdd82f6-1de4-4c4f-b680-80720ab0926f",
      "061c100e-4031-4f21-a593-7c2210d8df8f",
      "882670d8-d5f2-4642-b0d3-627a6585493a",
      "01ba8333-84c8-4729-b2fc-b572137306a5",
      "774f16b5-f36f-413a-8388-aa23daf2077c",
      "8d777901-3dc2-4f54-a77e-31b6760d52af",
      "384e89e3-f76e-4a1c-9587-1fb448e16c25",
      "c5bfee2f-168b-4a1f-aea9-b5dc57c93036",
      "e147212e-957e-4e91-8dc1-e5b9f43cc44d",
      "0c715e8a-0ff0-4a88-b6f8-cc1f37f7793b"), type =
      c("AdaptiveTicker", "AdaptiveTicker", "AdaptiveTicker",
      "DaysTicker", "DaysTicker", "DaysTicker", "DaysTicker",
      "MonthsTicker", "MonthsTicker", "MonthsTicker", "MonthsTicker",
      "YearsTicker")), desired_num_ticks = 6L, num_minor_ticks = 0L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(tickers = tickers,
        desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Generate ticks spaced apart by specific, even multiples of days.
DaysTicker <- R6::R6Class("DaysTicker",
  inherit = SingleIntervalTicker,
  public = list(
    initialize = function(
      interval = NA, desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, days = list()
    ) {
      super$initialize(interval = interval,
        desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$days <- validate(days, "Seq ( Int  )")
    }
  ),
  private = list(
    # The intervals of days to use.
    days = NULL # Seq ( Int  )
  )
)

# Generate ticks at fixed, explicitly supplied locations.
FixedTicker <- R6::R6Class("FixedTicker",
  inherit = ContinuousTicker,
  public = list(
    initialize = function(
      desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, ticks = list()
    ) {
      super$initialize(desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$ticks <- validate(ticks, "Seq ( Float  )")
    }
  ),
  private = list(
    # List of tick locations.
    ticks = NULL # Seq ( Float  )
  )
)

# Generate ticks on a log scale.
LogTicker <- R6::R6Class("LogTicker",
  inherit = AdaptiveTicker,
  public = list(
    initialize = function(
      base = 10, mantissas = c(1L, 5L), max_interval = NA, min_interval = 0,
      desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(base = base, mantissas = mantissas,
        max_interval = max_interval, min_interval = min_interval,
        desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Generate ticks spaced apart by specific, even multiples of months.
MonthsTicker <- R6::R6Class("MonthsTicker",
  inherit = SingleIntervalTicker,
  public = list(
    initialize = function(
      interval = NA, desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, months = list()
    ) {
      super$initialize(interval = interval,
        desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$months <- validate(months, "Seq ( Int  )")
    }
  ),
  private = list(
    # The intervals of months to use.
    months = NULL # Seq ( Int  )
  )
)

# Generate evenly spaced ticks at a fixed interval regardless of scale.
SingleIntervalTicker <- R6::R6Class("SingleIntervalTicker",
  inherit = ContinuousTicker,
  public = list(
    initialize = function(
      desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, interval = NA
    ) {
      super$initialize(desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$interval <- validate(interval, "Float")
    }
  ),
  private = list(
    # The interval between adjacent ticks.
    interval = NULL # Float
  )
)

# A base class for all ticker types. Ticker is not generally useful to
# instantiate on its own.
Ticker <- R6::R6Class("Ticker",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Generate ticks spaced apart even numbers of years.
YearsTicker <- R6::R6Class("YearsTicker",
  inherit = SingleIntervalTicker,
  public = list(
    initialize = function(
      interval = NA, desired_num_ticks = 6L, num_minor_ticks = 5L,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(interval = interval,
        desired_num_ticks = desired_num_ticks,
        num_minor_ticks = num_minor_ticks, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# The BBoxTileSource has the same default tile origin as the
# WMTSTileSource but requested tiles use a {XMIN}, {YMIN}, {XMAX}, {YMAX}
# e.g. http://your.custom.tile.service?bbox={XMIN},{YMIN},{XMAX},{YMAX}.
BBoxTileSource <- R6::R6Class("BBoxTileSource",
  inherit = MercatorTileSource,
  public = list(
    initialize = function(
      wrap_around = TRUE, attribution = "",
      extra_url_vars = structure(list(), .Names = character(0)),
      initial_resolution = 156543.033928041, max_zoom = 30L, min_zoom = 0L,
      tile_size = 256L, url = "", x_origin_offset = 20037508.34,
      y_origin_offset = 20037508.34, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA,
      use_latlon = FALSE
    ) {
      super$initialize(wrap_around = wrap_around,
        attribution = attribution, extra_url_vars = extra_url_vars,
        initial_resolution = initial_resolution, max_zoom = max_zoom,
        min_zoom = min_zoom, tile_size = tile_size, url = url,
        x_origin_offset = x_origin_offset,
        y_origin_offset = y_origin_offset, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$use_latlon <- validate(use_latlon, "Bool")
    }
  ),
  private = list(
    # Flag which indicates option to output {XMIN},{YMIN},{XMAX},{YMAX} in
    # meters or latitude and longitude.
    use_latlon = NULL # Bool
  )
)

# MercatorTileSource is not generally useful to instantiate on its own,
# but is the parent class of other mercator tile services (e.g.
# WMTSTileSource).
MercatorTileSource <- R6::R6Class("MercatorTileSource",
  inherit = TileSource,
  public = list(
    initialize = function(
      attribution = "", extra_url_vars = structure(list(), .Names =
      character(0)), initial_resolution = 156543.033928041, max_zoom = 30L,
      min_zoom = 0L, tile_size = 256L, url = "", x_origin_offset = 20037508.34,
      y_origin_offset = 20037508.34, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA,
      wrap_around = TRUE
    ) {
      super$initialize(attribution = attribution,
        extra_url_vars = extra_url_vars,
        initial_resolution = initial_resolution, max_zoom = max_zoom,
        min_zoom = min_zoom, tile_size = tile_size, url = url,
        x_origin_offset = x_origin_offset,
        y_origin_offset = y_origin_offset, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)
      private$wrap_around <- validate(wrap_around, "Bool")
    }
  ),
  private = list(
    # Enables continuous horizontal panning by wrapping the x-axis based on
    # bounds of map.
    wrap_around = NULL # Bool
  )
)

# The QUADKEYTileSource has the same tile origin as the WMTSTileSource
# but requests tiles using a quadkey argument instead of X, Y, Z e.g.
# http://your.quadkey.tile.host/{Q}.png
QUADKEYTileSource <- R6::R6Class("QUADKEYTileSource",
  inherit = MercatorTileSource,
  public = list(
    initialize = function(
      wrap_around = TRUE, attribution = "",
      extra_url_vars = structure(list(), .Names = character(0)),
      initial_resolution = 156543.033928041, max_zoom = 30L, min_zoom = 0L,
      tile_size = 256L, url = "", x_origin_offset = 20037508.34,
      y_origin_offset = 20037508.34, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(wrap_around = wrap_around,
        attribution = attribution, extra_url_vars = extra_url_vars,
        initial_resolution = initial_resolution, max_zoom = max_zoom,
        min_zoom = min_zoom, tile_size = tile_size, url = url,
        x_origin_offset = x_origin_offset,
        y_origin_offset = y_origin_offset, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# The TMSTileSource can also be helpful in implementing tile renderers
# for custom tile sets, including non-spatial datasets.
TMSTileSource <- R6::R6Class("TMSTileSource",
  inherit = MercatorTileSource,
  public = list(
    initialize = function(
      wrap_around = TRUE, attribution = "",
      extra_url_vars = structure(list(), .Names = character(0)),
      initial_resolution = 156543.033928041, max_zoom = 30L, min_zoom = 0L,
      tile_size = 256L, url = "", x_origin_offset = 20037508.34,
      y_origin_offset = 20037508.34, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(wrap_around = wrap_around,
        attribution = attribution, extra_url_vars = extra_url_vars,
        initial_resolution = initial_resolution, max_zoom = max_zoom,
        min_zoom = min_zoom, tile_size = tile_size, url = url,
        x_origin_offset = x_origin_offset,
        y_origin_offset = y_origin_offset, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# A base class for all tile source types. TileSource is not generally
# useful to instantiate on its own. In general, tile sources are used as
# a required input for TileRenderer.
TileSource <- R6::R6Class("TileSource",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, attribution = "",
      extra_url_vars = structure(list(), .Names = character(0)),
      initial_resolution = NA, max_zoom = 30L, min_zoom = 0L, tile_size = 256L,
      url = "", x_origin_offset = NA, y_origin_offset = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$attribution <- validate(attribution, "String")
      private$extra_url_vars <- validate(extra_url_vars, "Dict ( String , Any  )")
      private$initial_resolution <- validate(initial_resolution, "Float")
      private$max_zoom <- validate(max_zoom, "Int")
      private$min_zoom <- validate(min_zoom, "Int")
      private$tile_size <- validate(tile_size, "Int")
      private$url <- validate(url, "String")
      private$x_origin_offset <- validate(x_origin_offset, "Float")
      private$y_origin_offset <- validate(y_origin_offset, "Float")
    }
  ),
  private = list(
    # Data provider attribution content. This can include HTML content.
    attribution = NULL, # String
    # A dictionary that maps url variable template keys to values. These
    # variables are useful for parts of tile urls which do not change from
    # tile to tile (e.g. server host name, or layer name).
    extra_url_vars = NULL, # Dict ( String , Any  )
    # Resolution (plot_units / pixels) of minimum zoom level of tileset
    # projection. None to auto-compute.
    initial_resolution = NULL, # Float
    # A maximum zoom level for the tile layer. This is the most zoomed-in
    # level.
    max_zoom = NULL, # Int
    # A minimum zoom level for the tile layer. This is the most zoomed-out
    # level.
    min_zoom = NULL, # Int
    # Tile size in pixels (e.g. 256)
    tile_size = NULL, # Int
    # Tile service url e.g., http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png
    url = NULL, # String
    # An x-offset in plot coordinates
    x_origin_offset = NULL, # Float
    # A y-offset in plot coordinates
    y_origin_offset = NULL # Float
  )
)

# This is the most common used tile source for web mapping applications.
# Such companies as Google, MapQuest, Stamen, Esri, and OpenStreetMap
# provide service which use the WMTS specification e.g.
# http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png.
WMTSTileSource <- R6::R6Class("WMTSTileSource",
  inherit = MercatorTileSource,
  public = list(
    initialize = function(
      wrap_around = TRUE, attribution = "",
      extra_url_vars = structure(list(), .Names = character(0)),
      initial_resolution = 156543.033928041, max_zoom = 30L, min_zoom = 0L,
      tile_size = 256L, url = "", x_origin_offset = 20037508.34,
      y_origin_offset = 20037508.34, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(wrap_around = wrap_around,
        attribution = attribution, extra_url_vars = extra_url_vars,
        initial_resolution = initial_resolution, max_zoom = max_zoom,
        min_zoom = min_zoom, tile_size = tile_size, url = url,
        x_origin_offset = x_origin_offset,
        y_origin_offset = y_origin_offset, js_callbacks = js_callbacks,
        name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Bases: bokeh.models.tools.Tool
Action <- R6::R6Class("Action",
  inherit = Tool,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# See Selected and Unselected Glyphs for information on styling selected
# and unselected glyphs.
BoxSelectTool <- R6::R6Class("BoxSelectTool",
  inherit = Drag,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, callback = NA, dimensions = "both",
      names = list(), overlay = NA, renderers = list(),
      select_every_mousemove = FALSE
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$dimensions <- validate(dimensions, "Enum ( Dimensions  )")
      private$names <- validate(names, "List ( String  )")
      private$overlay <- validate(overlay, "Instance ( BoxAnnotation  )")
      private$renderers <- validate(renderers, "List ( Instance ( Renderer  ) )")
      private$select_every_mousemove <- validate(select_every_mousemove, "Bool")
    }
  ),
  private = list(
    # A callback to run in the browser on completion of drawing a selection
    # box. The cb_data parameter that is available to the Callback code will
    # contain one BoxSelectTool-specific field:
    callback = NULL, # Instance ( Callback  )
    # Which dimensions the box selection is to be free in. By default, users
    # may freely draw selections boxes with any dimensions. If only “width”
    # is supplied, the box will be constrained to span the entire vertical
    # space of the plot, only the horizontal dimension can be controlled. If
    # only “height” is supplied, the box will be constrained to span the
    # entire horizontal space of the plot, and the vertical dimension can be
    # controlled.
    dimensions = NULL, # Enum ( Dimensions  )
    # A list of names to query for. If set, only renderers that have a
    # matching value for their name attribute will be used.
    names = NULL, # List ( String  )
    # A shaded annotation drawn to indicate the selection region.
    overlay = NULL, # Instance ( BoxAnnotation  )
    # An explicit list of renderers to hit test again. If unset, defaults to
    # all renderers on a plot.
    renderers = NULL, # List ( Instance ( Renderer  ) )
    # Whether a selection computation should happen on every mouse event, or
    # only once, when the selection region is completed. Default: False
    select_every_mousemove = NULL # Bool
  )
)

# The box zoom tool allows users to define a rectangular region of a Plot
# to zoom to by dragging he mouse or a finger over the plot region. The
# end of the drag event indicates the selection region is ready.
BoxZoomTool <- R6::R6Class("BoxZoomTool",
  inherit = Drag,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, dimensions = "both",
      match_aspect = FALSE, overlay = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$dimensions <- validate(dimensions, "Enum ( Dimensions  )")
      private$match_aspect <- validate(match_aspect, "Bool")
      private$overlay <- validate(overlay, "Instance ( BoxAnnotation  )")
    }
  ),
  private = list(
    # Which dimensions the zoom box is to be free in. By default, users may
    # freely draw zoom boxes with any dimensions. If only “width” is
    # supplied, the box will be constrained to span the entire vertical space
    # of the plot, only the horizontal dimension can be controlled. If only
    # “height” is supplied, the box will be constrained to span the entire
    # horizontal space of the plot, and the vertical dimension can be
    # controlled.
    dimensions = NULL, # Enum ( Dimensions  )
    # Whether the box zoom region should be restricted to have the same
    # aspect ratio as the plot region.
    match_aspect = NULL, # Bool
    # A shaded annotation drawn to indicate the selection region.
    overlay = NULL # Instance ( BoxAnnotation  )
  )
)

# The crosshair tool draws a crosshair annotation over the plot, centered
# on the current mouse position. The crosshair tool may be configured to
# draw across only one dimension by setting the dimension property to
# only width or height.
CrosshairTool <- R6::R6Class("CrosshairTool",
  inherit = Inspection,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, dimensions = "both", line_alpha = 1,
      line_color = "black", line_width = 1L
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$dimensions <- validate(dimensions, "Enum ( Dimensions  )")
      private$line_alpha <- validate(line_alpha, "Float")
      private$line_color <- validate(line_color, "Color")
      private$line_width <- validate(line_width, "Float")
    }
  ),
  private = list(
    # Which dimensions the crosshair tool is to track. By default, both a
    # vertical and horizontal line will be drawn. If only “width” is
    # supplied, only a horizontal line will be drawn. If only “height” is
    # supplied, only a vertical line will be drawn.
    dimensions = NULL, # Enum ( Dimensions  )
    # An alpha value to use to stroke paths with. Acceptable values are
    # floating point numbers between 0 (transparent) and 1 (opaque).
    line_alpha = NULL, # Float
    # A color to use to stroke paths with. Acceptable values are:
    line_color = NULL, # Color
    # Stroke width in units of pixels.
    line_width = NULL # Float
  )
)

# Bases: bokeh.models.tools.Tool
Drag <- R6::R6Class("Drag",
  inherit = Tool,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# The help tool is a widget designed to replace the hardcoded ‘Help’
# link. The hover text can be customized through the help_tooltip
# attribute and the redirect site overridden as well.
HelpTool <- R6::R6Class("HelpTool",
  inherit = Action,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, help_tooltip = "Click the question
      mark to learn more about Bokeh plot tools.",
      redirect = "http://bokeh.pydata.org/en/latest/docs/user_guide/tools.html"
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$help_tooltip <- validate(help_tooltip, "String")
      private$redirect <- validate(redirect, "String")
    }
  ),
  private = list(
    # Tooltip displayed when hovering over the help icon.
    help_tooltip = NULL, # String
    # Site to be redirected through upon click.
    redirect = NULL # String
  )
)

# You can also supply a Callback to the HoverTool, to build custom
# interactions on hover. In this case you may want to turn the tooltips
# off by setting tooltips=None.
HoverTool <- R6::R6Class("HoverTool",
  inherit = Inspection,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, anchor = "center",
      attachment = "horizontal", callback = NA, line_policy = "prev",
      mode = "mouse", names = list(), point_policy = "snap_to_data",
      renderers = list(), show_arrow = TRUE, tooltips = structure(c("index",
      "data (x, y)", "canvas (x, y)", "$index", "($x, $y)", "($sx,
      $sy)"), .Dim = c(3L, 2L))
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$anchor <- validate(anchor, "Enum ( LegendLocation  )")
      private$attachment <- validate(attachment, "Enum ( Enumeration(horizontal, vertical) )")
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$line_policy <- validate(line_policy, "Enum ( Enumeration(prev, next, nearest, interp, none) )")
      private$mode <- validate(mode, "Enum ( Enumeration(mouse, hline, vline) )")
      private$names <- validate(names, "List ( String  )")
      private$point_policy <- validate(point_policy, "Enum ( Enumeration(snap_to_data, follow_mouse, none) )")
      private$renderers <- validate(renderers, "List ( Instance ( Renderer  ) )")
      private$show_arrow <- validate(show_arrow, "Bool")
      private$tooltips <- validate(tooltips, "Either ( String , List ( Tuple ( String , String  ) ) )")
    }
  ),
  private = list(
    # If point policy is set to “snap_to_data”, anchor defines the attachment
    # point of a tooltip. The default is to attach to the center of a glyph.
    anchor = NULL, # Enum ( LegendLocation  )
    # Whether tooltip’s arrow should appear in the horizontal or vertical
    # dimension.
    attachment = NULL, # Enum ( Enumeration(horizontal, vertical) )
    # A callback to run in the browser whenever the input’s value changes.
    # The cb_data parameter that is available to the Callback code will
    # contain two HoverTool specific fields:
    callback = NULL, # Instance ( Callback  )
    # When showing tooltips for lines, whether the tooltip position should be
    # the “previous” or “next” points on the line, the nearest point to the
    # current mouse position, or interpolate along the line to the current
    # mouse position.
    line_policy = NULL, # Enum ( Enumeration(prev, next, nearest, interp, none) )
    # Whether to consider hover pointer as a point (x/y values), or a span on
    # h or v directions.
    mode = NULL, # Enum ( Enumeration(mouse, hline, vline) )
    # A list of names to query for. If set, only renderers that have a
    # matching value for their name attribute will be used.
    names = NULL, # List ( String  )
    # Whether the tooltip position should snap to the “center” (or other
    # anchor) position of the associated glyph, or always follow the current
    # mouse cursor position.
    point_policy = NULL, # Enum ( Enumeration(snap_to_data, follow_mouse, none) )
    # An explicit list of renderers to hit test again. If unset, defaults to
    # all renderers on a plot.
    renderers = NULL, # List ( Instance ( Renderer  ) )
    # Whether tooltip’s arrow should be showed.
    show_arrow = NULL, # Bool
    # The (name, field) pairs describing what the hover tool should display
    # when there is a hit. Field names starting with “@” are interpreted as
    # columns on the data source. For instance, “@temp” would look up values
    # to display from the “temp” column of the data source. Field names
    # starting with “$” are special, known fields: Additional format options
    # safe and Numbro format codes can be included in a post-fix brace block
    # on field names. Including {safe} after a field name will override
    # automatic escaping of the tooltip data source. Any HTML tags in the
    # data tags will be rendered as HTML in the resulting HoverTool output.
    # See Custom Tooltip for a more detailed example. None is also a valid
    # value for tooltips. This turns off the rendering of tooltips. This is
    # mostly useful when supplying other actions on hover via the callback
    # property.
    tooltips = NULL # Either ( String , List ( Tuple ( String , String  ) ) )
  )
)

# Bases: bokeh.models.tools.Tool
Inspection <- R6::R6Class("Inspection",
  inherit = Tool,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# See Selected and Unselected Glyphs for information on styling selected
# and unselected glyphs.
LassoSelectTool <- R6::R6Class("LassoSelectTool",
  inherit = Drag,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, callback = NA, names = list(),
      overlay = NA, renderers = list(), select_every_mousemove = TRUE
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$names <- validate(names, "List ( String  )")
      private$overlay <- validate(overlay, "Instance ( PolyAnnotation  )")
      private$renderers <- validate(renderers, "List ( Instance ( Renderer  ) )")
      private$select_every_mousemove <- validate(select_every_mousemove, "Bool")
    }
  ),
  private = list(
    # A callback to run in the browser on every selection of a lasso area.
    # The cb_data parameter that is available to the Callback code will
    # contain one LassoSelectTool-specific field:
    callback = NULL, # Instance ( Callback  )
    # A list of names to query for. If set, only renderers that have a
    # matching value for their name attribute will be used.
    names = NULL, # List ( String  )
    # A shaded annotation drawn to indicate the selection region.
    overlay = NULL, # Instance ( PolyAnnotation  )
    # An explicit list of renderers to hit test again. If unset, defaults to
    # all renderers on a plot.
    renderers = NULL, # List ( Instance ( Renderer  ) )
    # Whether a selection computation should happen on every mouse event, or
    # only once, when the selection region is completed. Default: True
    select_every_mousemove = NULL # Bool
  )
)

# The pan tool also activates the border regions of a Plot for “single
# axis” panning. For instance, dragging in the vertical border or axis
# will effect a pan in the vertical direction only, with the horizontal
# dimension kept fixed.
PanTool <- R6::R6Class("PanTool",
  inherit = Drag,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, dimensions = "both"
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$dimensions <- validate(dimensions, "Enum ( Dimensions  )")
    }
  ),
  private = list(
    # Which dimensions the pan tool is constrained to act in. By default the
    # pan tool will pan in any dimension, but can be configured to only pan
    # horizontally across the width of the plot, or vertically across the
    # height of the plot.
    dimensions = NULL # Enum ( Dimensions  )
  )
)

# See Selected and Unselected Glyphs for information on styling selected
# and unselected glyphs.
PolySelectTool <- R6::R6Class("PolySelectTool",
  inherit = Tap,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, names = list(), overlay = NA,
      renderers = list()
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$names <- validate(names, "List ( String  )")
      private$overlay <- validate(overlay, "Instance ( PolyAnnotation  )")
      private$renderers <- validate(renderers, "List ( Instance ( Renderer  ) )")
    }
  ),
  private = list(
    # A list of names to query for. If set, only renderers that have a
    # matching value for their name attribute will be used.
    names = NULL, # List ( String  )
    # A shaded annotation drawn to indicate the selection region.
    overlay = NULL, # Instance ( PolyAnnotation  )
    # An explicit list of renderers to hit test again. If unset, defaults to
    # all renderers on a plot.
    renderers = NULL # List ( Instance ( Renderer  ) )
  )
)

# Redo tool reverses the last action performed by undo tool.
RedoTool <- R6::R6Class("RedoTool",
  inherit = Action,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Optionally, the reset tool also resets the plat canvas dimensions to
# their original size
ResetTool <- R6::R6Class("ResetTool",
  inherit = Action,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, reset_size = TRUE
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$reset_size <- validate(reset_size, "Bool")
    }
  ),
  private = list(
    # Whether activating the Reset tool should also reset the plot’s canvas
    # dimensions to their original size.
    reset_size = NULL # Bool
  )
)

# The resize tool allows the user to left-drag a mouse or drag a finger
# to resize the entire plot area on the screen.
ResizeTool <- R6::R6Class("ResizeTool",
  inherit = Drag,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# The save tool is an action. When activated, the tool opens a download
# dialog which allows to save an image reproduction of the plot in PNG
# format. If automatic download is not support by a web browser, the tool
# falls back to opening the generated image in a new tab or window. User
# then can manually save it by right clicking on the image and choosing
# “Save As” (or similar) menu item.
SaveTool <- R6::R6Class("SaveTool",
  inherit = Action,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Bases: bokeh.models.tools.Tool
Scroll <- R6::R6Class("Scroll",
  inherit = Tool,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Bases: bokeh.models.tools.Tool
Tap <- R6::R6Class("Tap",
  inherit = Tool,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# See Selected and Unselected Glyphs for information on styling selected
# and unselected glyphs.
TapTool <- R6::R6Class("TapTool",
  inherit = Tap,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, behavior = "select", callback = NA,
      names = list(), renderers = list()
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$behavior <- validate(behavior, "Enum ( Enumeration(select, inspect) )")
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$names <- validate(names, "List ( String  )")
      private$renderers <- validate(renderers, "List ( Instance ( Renderer  ) )")
    }
  ),
  private = list(
    # This tool can be configured to either make selections or inspections on
    # associated data sources. The difference is that selection changes
    # propagate across bokeh and other components (e.g. selection glyph) will
    # be notified. Inspecions don’t act like this, so it’s useful to
    # configure callback when setting behavior=’inspect’.
    behavior = NULL, # Enum ( Enumeration(select, inspect) )
    # A client-side action specification, like opening a URL, showing a
    # dialog box, etc. See Action for details.
    callback = NULL, # Instance ( Callback  )
    # A list of names to query for. If set, only renderers that have a
    # matching value for their name attribute will be used.
    names = NULL, # List ( String  )
    # An explicit list of renderers to hit test again. If unset, defaults to
    # all renderers on a plot.
    renderers = NULL # List ( Instance ( Renderer  ) )
  )
)

# A base class for all interactive tool types. Tool is not generally
# useful to instantiate on its own.
Tool <- R6::R6Class("Tool",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, plot = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$plot <- validate(plot, "Instance ( Plot  )")
    }
  ),
  private = list(
    # The Plot that this tool will act on.
    plot = NULL # Instance ( Plot  )
  )
)

# Bases: bokeh.model.Model
ToolEvents <- R6::R6Class("ToolEvents",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, geometries = list()
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$geometries <- validate(geometries, "List ( Dict ( String , Any  ) )")
    }
  ),
  private = list(
    # 
    geometries = NULL # List ( Dict ( String , Any  ) )
  )
)

# Hold tools to display for a single plot.
Toolbar <- R6::R6Class("Toolbar",
  inherit = ToolbarBase,
  public = list(
    initialize = function(
      logo = "normal", tools = list(), css_classes = NA, disabled = FALSE,
      height = NA, sizing_mode = NA, width = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, active_drag = "auto", active_scroll = "auto",
      active_tap = "auto"
    ) {
      super$initialize(logo = logo, tools = tools, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$active_drag <- validate(active_drag, "Either ( Auto , Instance ( Drag  ) )")
      private$active_scroll <- validate(active_scroll, "Either ( Auto , Instance ( Scroll  ) )")
      private$active_tap <- validate(active_tap, "Either ( Auto , Instance ( Tap  ) )")
    }
  ),
  private = list(
    # Specify a drag tool to be active when the plot is displayed.
    active_drag = NULL, # Either ( Auto , Instance ( Drag  ) )
    # Specify a scroll/pinch tool to be active when the plot is displayed.
    active_scroll = NULL, # Either ( Auto , Instance ( Scroll  ) )
    # Specify a tap/click tool to be active when the plot is displayed.
    active_tap = NULL # Either ( Auto , Instance ( Tap  ) )
  )
)

# A base class for different toolbars. ToolbarBase is not generally
# useful to instantiate on its own.
ToolbarBase <- R6::R6Class("ToolbarBase",
  inherit = LayoutDOM,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = NA,
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, logo = "normal", tools = list()
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$logo <- validate(logo, "Enum ( Enumeration(normal, grey) )")
      private$tools <- validate(tools, "List ( Instance ( Tool  ) )")
    }
  ),
  private = list(
    # What version of the Bokeh logo to display on the toolbar. If set to
    # None, no logo will be displayed.
    logo = NULL, # Enum ( Enumeration(normal, grey) )
    # A list of tools to add to the plot.
    tools = NULL # List ( Instance ( Tool  ) )
  )
)

# A layoutable toolbar that can accept the tools of multiple plots, and
# can merge the tools into a single button for convenience.
ToolbarBox <- R6::R6Class("ToolbarBox",
  inherit = Box,
  public = list(
    initialize = function(
      children = list(), css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA,
      logo = "normal", merge_tools = TRUE, toolbar_location = "right",
      tools = list()
    ) {
      super$initialize(children = children, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$logo <- validate(logo, "Enum ( Enumeration(normal, grey) )")
      private$merge_tools <- validate(merge_tools, "Bool")
      private$toolbar_location <- validate(toolbar_location, "Enum ( Location  )")
      private$tools <- validate(tools, "List ( Instance ( Tool  ) )")
    }
  ),
  private = list(
    # What version of the Bokeh logo to display on the toolbar. If set to
    # None, no logo will be displayed.
    logo = NULL, # Enum ( Enumeration(normal, grey) )
    # Merge all the tools together so there is one tool to control all the
    # plots.
    merge_tools = NULL, # Bool
    # Should the toolbar be presented as if it was stuck to the above, right,
    # left, below edge of a plot. Default is right.
    toolbar_location = NULL, # Enum ( Location  )
    # A list of tools to add to the plot.
    tools = NULL # List ( Instance ( Tool  ) )
  )
)

# Undo tool allows to restore previous state of the plot.
UndoTool <- R6::R6Class("UndoTool",
  inherit = Action,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# The wheel pan tool allows the user to pan the plot along the configured
# dimension using the scroll wheel.
WheelPanTool <- R6::R6Class("WheelPanTool",
  inherit = Scroll,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, dimension = "width"
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$dimension <- validate(dimension, "Enum ( Dimension  )")
    }
  ),
  private = list(
    # Which dimension the wheel pan tool is constrained to act in. By default
    # the wheel pan tool will pan the plot along the x-axis.
    dimension = NULL # Enum ( Dimension  )
  )
)

# The wheel zoom tool also activates the border regions of a Plot for
# “single axis” zooming. For instance, zooming in the vertical border or
# axis will effect a zoom in the vertical direction only, with the
# horizontal dimension kept fixed.
WheelZoomTool <- R6::R6Class("WheelZoomTool",
  inherit = Scroll,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, dimensions = "both"
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$dimensions <- validate(dimensions, "Enum ( Dimensions  )")
    }
  ),
  private = list(
    # Which dimensions the wheel zoom tool is constrained to act in. By
    # default the wheel zoom tool will zoom in any dimension, but can be
    # configured to only zoom horizontally across the width of the plot, or
    # vertically across the height of the plot.
    dimensions = NULL # Enum ( Dimensions  )
  )
)

# The zoom-in tool allows users to click a button to zoom in by a fixed
# amount.
ZoomInTool <- R6::R6Class("ZoomInTool",
  inherit = Action,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, dimensions = "both", factor = 0.1
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$dimensions <- validate(dimensions, "Enum ( Dimensions  )")
      private$factor <- validate(factor, "Percent")
    }
  ),
  private = list(
    # Which dimensions the zoom-in tool is constrained to act in. By default
    # the zoom-in zoom tool will zoom in any dimension, but can be configured
    # to only zoom horizontally across the width of the plot, or vertically
    # across the height of the plot.
    dimensions = NULL, # Enum ( Dimensions  )
    # Percentage to zoom for each click of the zoom-in tool.
    factor = NULL # Percent
  )
)

# The zoom-out tool allows users to click a button to zoom out by a fixed
# amount.
ZoomOutTool <- R6::R6Class("ZoomOutTool",
  inherit = Action,
  public = list(
    initialize = function(
      plot = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, dimensions = "both", factor = 0.1
    ) {
      super$initialize(plot = plot, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$dimensions <- validate(dimensions, "Enum ( Dimensions  )")
      private$factor <- validate(factor, "Percent")
    }
  ),
  private = list(
    # Which dimensions the zoom-out tool is constrained to act in. By default
    # the zoom-out tool will zoom in any dimension, but can be configured to
    # only zoom horizontally across the width of the plot, or vertically
    # across the height of the plot.
    dimensions = NULL, # Enum ( Dimensions  )
    # Percentage to zoom for each click of the zoom-in tool.
    factor = NULL # Percent
  )
)

# This is the base class and is not intended to end use.  Please see the
# documentation for the final derived classes (Jitter,
# LineraInterpolator, StepInterpolator) for mor information on their
# specific methods of interpolation.
Interpolator <- R6::R6Class("Interpolator",
  inherit = Transform,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, clip = TRUE, data = NA, x = NA, y = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$clip <- validate(clip, "Bool")
      private$data <- validate(data, "Instance ( ColumnarDataSource  )")
      private$x <- validate(x, "Either ( String , Seq ( Float  ) )")
      private$y <- validate(y, "Either ( String , Seq ( Float  ) )")
    }
  ),
  private = list(
    # Determine if the interpolation should clip the result to include only
    # values inside its predefined range. If this is set to False, it will
    # return the most value of the closest point.
    clip = NULL, # Bool
    # Data which defines the source for the named columns if a string is
    # passed to either the x or y parameters.
    data = NULL, # Instance ( ColumnarDataSource  )
    # Independant coordiante denoting the location of a point.
    x = NULL, # Either ( String , Seq ( Float  ) )
    # Dependant coordinate denoting the value of a point at a location.
    y = NULL # Either ( String , Seq ( Float  ) )
  )
)

# Apply either a uniform or normally sampled random jitter to data.
Jitter <- R6::R6Class("Jitter",
  inherit = Transform,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, distribution = "uniform", mean = 0L, width = 1L
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$distribution <- validate(distribution, "Enum ( JitterRandomDistribution  )")
      private$mean <- validate(mean, "Float")
      private$width <- validate(width, "Float")
    }
  ),
  private = list(
    # The random distribution upon which to pull the random scatter
    distribution = NULL, # Enum ( JitterRandomDistribution  )
    # The central value for the random sample
    mean = NULL, # Float
    # The width (absolute for uniform distribution and sigma for the normal
    # distribution) of the random sample.
    width = NULL # Float
  )
)

# Compute a linear interpolation between the control points provided
# throught the x, y, and data parameters.
LinearInterpolator <- R6::R6Class("LinearInterpolator",
  inherit = Interpolator,
  public = list(
    initialize = function(
      clip = TRUE, data = NA, x = NA, y = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(clip = clip, data = data, x = x, y = y,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Compute a step-wise interpolation between the points provided throught
# the x, y, and data parameters.
StepInterpolator <- R6::R6Class("StepInterpolator",
  inherit = Interpolator,
  public = list(
    initialize = function(
      clip = TRUE, data = NA, x = NA, y = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, mode = "after"
    ) {
      super$initialize(clip = clip, data = data, x = x, y = y,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$mode <- validate(mode, "Enum ( StepMode  )")
    }
  ),
  private = list(
    # Adjust the behavior of the returned value in relation to the control
    # points.  The parameter can assume one of three values:
    mode = NULL # Enum ( StepMode  )
  )
)

# JavaScript implementations should implement the following methods:
Transform <- R6::R6Class("Transform",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Shared properties for button-like widgets.
ButtonLike <- R6::R6Class("ButtonLike",
  public = list(
    initialize = function(
      button_type = ""
    ) {
      private$button_type <- validate(button_type, "Enum ( ButtonType  )")
    }
  ),
  private = list(
    # A style for the button, signifying it’s role.
    button_type = NULL # Enum ( ButtonType  )
  )
)

# A dropdown button.
Dropdown <- R6::R6Class("Dropdown",
  inherit = AbstractButton,
  public = list(
    initialize = function(
      callback = NA, icon = NA, label = "Dropdown", default_value = NA,
      menu = list(), value = NA
    ) {
      super$initialize(callback = callback, icon = icon, label = label)
      private$default_value <- validate(default_value, "String")
      private$menu <- validate(menu, "List ( Tuple ( String , String  ) )")
      private$value <- validate(value, "String")
    }
  ),
  private = list(
    # The default value, otherwise the first item in menu will be used.
    default_value = NULL, # String
    # Button’s dropdown menu consisting of entries containing item’s text and
    # value name. Use None as a menu separator.
    menu = NULL, # List ( Tuple ( String , String  ) )
    # A private property used to trigger on_click event handler.
    value = NULL # String
  )
)

# A two-state toggle button.
Toggle <- R6::R6Class("Toggle",
  inherit = AbstractButton,
  public = list(
    initialize = function(
      callback = NA, icon = NA, label = "Toggle", active = FALSE
    ) {
      super$initialize(callback = callback, icon = icon, label = label)
      private$active <- validate(active, "Bool")
    }
  ),
  private = list(
    # The initial state of a button. Also used to trigger on_click event
    # handler.
    active = NULL # Bool
  )
)

# Abstract base class for all kinds of groups. AbstractGroup is not
# generally useful to instantiate on its own.
AbstractGroup <- R6::R6Class("AbstractGroup",
  inherit = Widget,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, callback = NA, labels = list()
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$labels <- validate(labels, "List ( String  )")
    }
  ),
  private = list(
    # A callback to run in the browser whenever a button group is
    # manipulated.
    callback = NULL, # Instance ( Callback  )
    # List of text labels contained in this group.
    labels = NULL # List ( String  )
  )
)

# A group of check boxes rendered as toggle buttons.
CheckboxButtonGroup <- R6::R6Class("CheckboxButtonGroup",
  inherit = ButtonGroup,
  public = list(
    initialize = function(
      active = list()
    ) {
      private$active <- validate(active, "List ( Int  )")
    }
  ),
  private = list(
    # The list of indices of selected check boxes.
    active = NULL # List ( Int  )
  )
)

# A group of check boxes.
CheckboxGroup <- R6::R6Class("CheckboxGroup",
  inherit = Group,
  public = list(
    initialize = function(
      inline = FALSE, callback = NA, labels = list(), css_classes = NA,
      disabled = FALSE, height = NA, sizing_mode = "fixed", width = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, active = list()
    ) {
      super$initialize(inline = inline, callback = callback, labels = labels,
        css_classes = css_classes, disabled = disabled, height = height,
        sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$active <- validate(active, "List ( Int  )")
    }
  ),
  private = list(
    # The list of indices of selected check boxes.
    active = NULL # List ( Int  )
  )
)

# Abstract base class for groups with items rendered as check/radio
# boxes.
Group <- R6::R6Class("Group",
  inherit = AbstractGroup,
  public = list(
    initialize = function(
      callback = NA, labels = list(), css_classes = NA, disabled = FALSE,
      height = NA, sizing_mode = "fixed", width = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, inline = FALSE
    ) {
      super$initialize(callback = callback, labels = labels,
        css_classes = css_classes, disabled = disabled, height = height,
        sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$inline <- validate(inline, "Bool")
    }
  ),
  private = list(
    # Should items be arrange vertically (False) or horizontally in-line
    # (True).
    inline = NULL # Bool
  )
)

# A group of radio boxes rendered as toggle buttons.
RadioButtonGroup <- R6::R6Class("RadioButtonGroup",
  inherit = ButtonGroup,
  public = list(
    initialize = function(
      active = NA
    ) {
      private$active <- validate(active, "Int")
    }
  ),
  private = list(
    # The index of the selected radio box, or None if nothing is selected.
    active = NULL # Int
  )
)

# A group of radio boxes.
RadioGroup <- R6::R6Class("RadioGroup",
  inherit = Group,
  public = list(
    initialize = function(
      inline = FALSE, callback = NA, labels = list(), css_classes = NA,
      disabled = FALSE, height = NA, sizing_mode = "fixed", width = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, active = NA
    ) {
      super$initialize(inline = inline, callback = callback, labels = labels,
        css_classes = css_classes, disabled = disabled, height = height,
        sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$active <- validate(active, "Int")
    }
  ),
  private = list(
    # The index of the selected radio box, or None if nothing is selected.
    active = NULL # Int
  )
)

# An abstract base class for icon widgets. AbstractIcon is not generally
# useful to instantiate on its own.
AbstractIcon <- R6::R6Class("AbstractIcon",
  inherit = Widget,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

# Single-line input widget with auto-completion.
AutocompleteInput <- R6::R6Class("AutocompleteInput",
  inherit = TextInput,
  public = list(
    initialize = function(
      callback = NA, placeholder = "", value = "", title = "", css_classes = NA,
      disabled = FALSE, height = NA, sizing_mode = "fixed", width = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, completions = list()
    ) {
      super$initialize(callback = callback, placeholder = placeholder,
        value = value, title = title, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$completions <- validate(completions, "List ( String  )")
    }
  ),
  private = list(
    # A list of completion strings. This will be used to guide the user upon
    # typing the beginning of a desired value.
    completions = NULL # List ( String  )
  )
)

# Calendar-based date picker widget.
DatePicker <- R6::R6Class("DatePicker",
  inherit = InputWidget,
  public = list(
    initialize = function(
      title = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, callback = NA,
      max_date = NA, min_date = NA, value = 1483920000000
    ) {
      super$initialize(title = title, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$max_date <- validate(max_date, "Date")
      private$min_date <- validate(min_date, "Date")
      private$value <- validate(value, "Date")
    }
  ),
  private = list(
    # A callback to run in the browser whenever the current date value
    # changes.
    callback = NULL, # Instance ( Callback  )
    # Optional latest allowable date.
    max_date = NULL, # Date
    # Optional earliest allowable date.
    min_date = NULL, # Date
    # The initial or picked date.
    value = NULL # Date
  )
)

# Slider-based date range selection widget.
DateRangeSlider <- R6::R6Class("DateRangeSlider",
  inherit = InputWidget,
  public = list(
    initialize = function(
      title = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, arrows = TRUE,
      bounds = NA, callback = NA, enabled = TRUE, range = NA,
      step = structure(list(), .Names = character(0)), value = NA,
      value_labels = "show", wheel_mode = NA
    ) {
      super$initialize(title = title, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$arrows <- validate(arrows, "Bool")
      private$bounds <- validate(bounds, "Tuple ( Date , Date  )")
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$enabled <- validate(enabled, "Bool")
      private$range <- validate(range, "Tuple ( RelativeDelta ( Enum ( Enumeration(years, months, days, hours, minutes, seconds, microseconds) ), Int  ), RelativeDelta ( Enum ( Enumeration(years, months, days, hours, minutes, seconds, microseconds) ), Int  ) )")
      private$step <- validate(step, "RelativeDelta ( Enum ( Enumeration(years, months, days, hours, minutes, seconds, microseconds) ), Int  )")
      private$value <- validate(value, "Tuple ( Date , Date  )")
      private$value_labels <- validate(value_labels, "Enum ( Enumeration(show, hide, change) )")
      private$wheel_mode <- validate(wheel_mode, "Enum ( Enumeration(scroll, zoom) )")
    }
  ),
  private = list(
    # Whether to show clickable arrows on both ends of the slider.
    arrows = NULL, # Bool
    # The earliest and latest allowable dates.
    bounds = NULL, # Tuple ( Date , Date  )
    # A callback to run in the browser whenever either slider’s value
    # changes.
    callback = NULL, # Instance ( Callback  )
    # Enable or disable this widget.
    enabled = NULL, # Bool
    # [TDB]
    range = NULL, # Tuple ( RelativeDelta ( Enum ( Enumeration(years, months, days, hours, minutes, seconds, microseconds) ), Int  ), RelativeDelta ( Enum ( Enumeration(years, months, days, hours, minutes, seconds, microseconds) ), Int  ) )
    # The step between consecutive dates.
    step = NULL, # RelativeDelta ( Enum ( Enumeration(years, months, days, hours, minutes, seconds, microseconds) ), Int  )
    # The initial or selected date range.
    value = NULL, # Tuple ( Date , Date  )
    # Show or hide value labels on both sides of the slider.
    value_labels = NULL, # Enum ( Enumeration(show, hide, change) )
    # Whether mouse zoom should scroll or zoom selected range (or do
    # nothing).
    wheel_mode = NULL # Enum ( Enumeration(scroll, zoom) )
  )
)

# Abstract base class for input widgets. InputWidget` is not generally
# useful to instantiate on its own.
InputWidget <- R6::R6Class("InputWidget",
  inherit = Widget,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, title = ""
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$title <- validate(title, "String")
    }
  ),
  private = list(
    # Widget’s label.
    title = NULL # String
  )
)

# Multi-select widget.
MultiSelect <- R6::R6Class("MultiSelect",
  inherit = InputWidget,
  public = list(
    initialize = function(
      title = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, callback = NA,
      options = list(), size = 4L, value = list()
    ) {
      super$initialize(title = title, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$options <- validate(options, "List ( Either ( String , Tuple ( String , String  ) ) )")
      private$size <- validate(size, "Int")
      private$value <- validate(value, "List ( String  )")
    }
  ),
  private = list(
    # A callback to run in the browser whenever the current selection value
    # changes.
    callback = NULL, # Instance ( Callback  )
    # Available selection options. Options may be provided either as a list
    # of possible string values, or as a list of tuples, each of the form
    # (value, label). In the latter case, the visible widget text for each
    # value will be corresponding given label.
    options = NULL, # List ( Either ( String , Tuple ( String , String  ) ) )
    # The number of visible options in the dropdown list. (This uses the
    # select HTML element’s size attribute. Some browsers might not show less
    # than 3 options.)
    size = NULL, # Int
    # Initial or selected values.
    value = NULL # List ( String  )
  )
)

# Range-slider based range selection widget
RangeSlider <- R6::R6Class("RangeSlider",
  inherit = InputWidget,
  public = list(
    initialize = function(
      title = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, callback = NA,
      callback_policy = "throttle", callback_throttle = 200L, end = 1L,
      orientation = "horizontal", range = c(0.1, 0.9), start = 0L, step = 0.1
    ) {
      super$initialize(title = title, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$callback_policy <- validate(callback_policy, "Enum ( SliderCallbackPolicy  )")
      private$callback_throttle <- validate(callback_throttle, "Float")
      private$end <- validate(end, "Float")
      private$orientation <- validate(orientation, "Enum ( Enumeration(horizontal, vertical) )")
      private$range <- validate(range, "Tuple ( Float , Float  )")
      private$start <- validate(start, "Float")
      private$step <- validate(step, "Float")
    }
  ),
  private = list(
    # A callback to run in the browser whenever the current Slider value
    # changes.
    callback = NULL, # Instance ( Callback  )
    # When the callback is initiated. This parameter can take on only one of
    # three options: The “mouseup” policy is intended for scenarios in which
    # the callback is expensive in time.
    callback_policy = NULL, # Enum ( SliderCallbackPolicy  )
    # Number of microseconds to pause between callback calls as the slider is
    # moved.
    callback_throttle = NULL, # Float
    # The maximum allowable value.
    end = NULL, # Float
    # Orient the slider either horizontally (default) or vertically.
    orientation = NULL, # Enum ( Enumeration(horizontal, vertical) )
    # Initial or selected range.
    range = NULL, # Tuple ( Float , Float  )
    # The minimum allowable value.
    start = NULL, # Float
    # The step between consecutive values.
    step = NULL # Float
  )
)

# Single-select widget.
Select <- R6::R6Class("Select",
  inherit = InputWidget,
  public = list(
    initialize = function(
      title = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, callback = NA,
      options = list(), value = ""
    ) {
      super$initialize(title = title, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$options <- validate(options, "List ( Either ( String , Tuple ( String , String  ) ) )")
      private$value <- validate(value, "String")
    }
  ),
  private = list(
    # A callback to run in the browser whenever the current Select dropdown
    # value changes.
    callback = NULL, # Instance ( Callback  )
    # Available selection options. Options may be provided either as a list
    # of possible string values, or as a list of tuples, each of the form
    # (value, label). In the latter case, the visible widget text for each
    # value will be corresponding given label.
    options = NULL, # List ( Either ( String , Tuple ( String , String  ) ) )
    # Initial or selected value.
    value = NULL # String
  )
)

# Slider-based number selection widget.
Slider <- R6::R6Class("Slider",
  inherit = InputWidget,
  public = list(
    initialize = function(
      title = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, callback = NA,
      callback_policy = "throttle", callback_throttle = 200L, end = 1L,
      orientation = "horizontal", start = 0L, step = 0.1, value = 0.5
    ) {
      super$initialize(title = title, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$callback_policy <- validate(callback_policy, "Enum ( SliderCallbackPolicy  )")
      private$callback_throttle <- validate(callback_throttle, "Float")
      private$end <- validate(end, "Float")
      private$orientation <- validate(orientation, "Enum ( Enumeration(horizontal, vertical) )")
      private$start <- validate(start, "Float")
      private$step <- validate(step, "Float")
      private$value <- validate(value, "Float")
    }
  ),
  private = list(
    # A callback to run in the browser whenever the current Slider value
    # changes.
    callback = NULL, # Instance ( Callback  )
    # When the callback is initiated. This parameter can take on only one of
    # three options: The “mouseup” policy is intended for scenarios in which
    # the callback is expensive in time.
    callback_policy = NULL, # Enum ( SliderCallbackPolicy  )
    # Number of microseconds to pause between callback calls as the slider is
    # moved.
    callback_throttle = NULL, # Float
    # The maximum allowable value.
    end = NULL, # Float
    # Orient the slider either horizontally (default) or vertically.
    orientation = NULL, # Enum ( Enumeration(horizontal, vertical) )
    # The minimum allowable value.
    start = NULL, # Float
    # The step between consecutive values.
    step = NULL, # Float
    # Initial or selected value.
    value = NULL # Float
  )
)

# Single-line input widget.
TextInput <- R6::R6Class("TextInput",
  inherit = InputWidget,
  public = list(
    initialize = function(
      title = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA, callback = NA,
      placeholder = "", value = ""
    ) {
      super$initialize(title = title, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$placeholder <- validate(placeholder, "String")
      private$value <- validate(value, "String")
    }
  ),
  private = list(
    # A callback to run in the browser whenever the user unfocuses the
    # TextInput widget by hitting Enter or clicking outside of the text box
    # area.
    callback = NULL, # Instance ( Callback  )
    # Placeholder for empty input field
    placeholder = NULL, # String
    # Initial or entered text value.
    value = NULL # String
  )
)

# A block (div) of text.
Div <- R6::R6Class("Div",
  inherit = Markup,
  public = list(
    initialize = function(
      text = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA,
      render_as_text = FALSE
    ) {
      super$initialize(text = text, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$render_as_text <- validate(render_as_text, "Bool")
    }
  ),
  private = list(
    # Should the text be rendered as raw text (False, default), or should the
    # text be interprited as an HTML string (True)
    render_as_text = NULL # Bool
  )
)

# Base class for HTML markup widget models.
Markup <- R6::R6Class("Markup",
  inherit = Widget,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, text = ""
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$text <- validate(text, "String")
    }
  ),
  private = list(
    # The contents of the widget.
    text = NULL # String
  )
)

# A block (paragraph) of text.
Paragraph <- R6::R6Class("Paragraph",
  inherit = Markup,
  public = list(
    initialize = function(
      text = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(text = text, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# A block (paragraph) of pre-formatted text.
PreText <- R6::R6Class("PreText",
  inherit = Paragraph,
  public = list(
    initialize = function(
      text = "", css_classes = NA, disabled = FALSE, height = NA,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA
    ) {
      super$initialize(text = text, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# A single-widget container with title bar and controls.
Panel <- R6::R6Class("Panel",
  inherit = Widget,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, child = NA, closable = FALSE, title = ""
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$child <- validate(child, "Instance ( LayoutDOM  )")
      private$closable <- validate(closable, "Bool")
      private$title <- validate(title, "String")
    }
  ),
  private = list(
    # The child widget. If you need more children, use a layout widget, e.g.
    # HBox or VBox.
    child = NULL, # Instance ( LayoutDOM  )
    # Whether this panel is closeable or not. If True, an “x” button will
    # appear.
    closable = NULL, # Bool
    # An optional text title of the panel.
    title = NULL # String
  )
)

# A panel widget with navigation tabs.
Tabs <- R6::R6Class("Tabs",
  inherit = Widget,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, active = 0L, callback = NA, tabs = list()
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$active <- validate(active, "Int")
      private$callback <- validate(callback, "Instance ( Callback  )")
      private$tabs <- validate(tabs, "List ( Instance ( Panel  ) )")
    }
  ),
  private = list(
    # The index of the active tab.
    active = NULL, # Int
    # A callback to run in the browser whenever the button is activated.
    callback = NULL, # Instance ( Callback  )
    # The list of child panel widgets.
    tabs = NULL # List ( Instance ( Panel  ) )
  )
)

# Boolean (check mark) cell formatter.
BooleanFormatter <- R6::R6Class("BooleanFormatter",
  inherit = CellFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, icon = "check"
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$icon <- validate(icon, "Enum ( Enumeration(check, check-circle, check-circle-o, check-square, check-square-o) )")
    }
  ),
  private = list(
    # The icon visualizing the check mark.
    icon = NULL # Enum ( Enumeration(check, check-circle, check-circle-o, check-square, check-square-o) )
  )
)

# Abstract base class for data table’s cell editors.
CellEditor <- R6::R6Class("CellEditor",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Abstract base class for data table’s cell formatters.
CellFormatter <- R6::R6Class("CellFormatter",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Boolean value cell editor.
CheckboxEditor <- R6::R6Class("CheckboxEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Two dimensional grid for visualisation and editing large amounts of
# data.
DataTable <- R6::R6Class("DataTable",
  inherit = TableWidget,
  public = list(
    initialize = function(
      source = NA, css_classes = NA, disabled = FALSE, height = 400L,
      sizing_mode = "fixed", width = NA, js_callbacks = structure(list(),
      .Names = character(0)), name = NA, tags = list(), id = NA,
      columns = list(), editable = FALSE, fit_columns = TRUE,
      row_headers = TRUE, scroll_to_selection = TRUE, selectable = TRUE,
      sortable = TRUE
    ) {
      super$initialize(source = source, css_classes = css_classes,
        disabled = disabled, height = height, sizing_mode = sizing_mode,
        width = width, js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$columns <- validate(columns, "List ( Instance ( TableColumn  ) )")
      private$editable <- validate(editable, "Bool")
      private$fit_columns <- validate(fit_columns, "Bool")
      private$row_headers <- validate(row_headers, "Bool")
      private$scroll_to_selection <- validate(scroll_to_selection, "Bool")
      private$selectable <- validate(selectable, "Either ( Bool , Enum ( Enumeration(checkbox) ) )")
      private$sortable <- validate(sortable, "Bool")
    }
  ),
  private = list(
    # The list of child column widgets.
    columns = NULL, # List ( Instance ( TableColumn  ) )
    # Allows to edit table’s contents. Needs cell editors to be configured on
    # columns that are required to be editable.
    editable = NULL, # Bool
    # Whether columns should be fit to the available width. This results in
    # no horizontal scrollbar showing up, but data can get unreadable if
    # there is no enough space available. If set to True, columns’ width is
    # understood as maximum width.
    fit_columns = NULL, # Bool
    # Enable or disable row headers, i.e. the index column.
    row_headers = NULL, # Bool
    # Whenever a selection is made on the data source, scroll the selected
    # rows into the table’s viewport if none of the selected rows are already
    # in the viewport.
    scroll_to_selection = NULL, # Bool
    # Whether a table’s rows can be selected or not. Using checkbox is
    # equivalent to True, but makes selection visible through a checkbox for
    # each row, instead of highlighting rows. Multiple selection is allowed
    # and can be achieved by either clicking multiple checkboxes (if enabled)
    # or using Shift + click on rows.
    selectable = NULL, # Either ( Bool , Enum ( Enumeration(checkbox) ) )
    # Allows to sort table’s contents. By default natural order is preserved.
    # To sort a column, click on it’s header. Clicking one more time changes
    # sort direction. Use Ctrl + click to return to natural order. Use Shift
    # + click to sort multiple columns simultaneously.
    sortable = NULL # Bool
  )
)

# Calendar-based date cell editor.
DateEditor <- R6::R6Class("DateEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Date cell formatter.
DateFormatter <- R6::R6Class("DateFormatter",
  inherit = CellFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, format = "yy M d"
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$format <- validate(format, "Either ( Enum ( DateFormat  ), String  )")
    }
  ),
  private = list(
    # The date format can be combinations of the following:
    format = NULL # Either ( Enum ( DateFormat  ), String  )
  )
)

# Example: Use values from other columns (manufacturer and model) to
# build a hyperlink.
HTMLTemplateFormatter <- R6::R6Class("HTMLTemplateFormatter",
  inherit = CellFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, template = "<%= value %>"
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$template <- validate(template, "String")
    }
  ),
  private = list(
    # Template string to be used by Underscore’s template method.
    template = NULL # String
  )
)

# Spinner-based integer cell editor.
IntEditor <- R6::R6Class("IntEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, step = 1L
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$step <- validate(step, "Int")
    }
  ),
  private = list(
    # The major step value.
    step = NULL # Int
  )
)

# Spinner-based number cell editor.
NumberEditor <- R6::R6Class("NumberEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, step = 0.01
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$step <- validate(step, "Float")
    }
  ),
  private = list(
    # The major step value.
    step = NULL # Float
  )
)

# Number cell formatter.
NumberFormatter <- R6::R6Class("NumberFormatter",
  inherit = StringFormatter,
  public = list(
    initialize = function(
      font_style = "normal", text_align = "left", text_color = NA,
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, format = "0,0", language = "en", rounding = "round"
    ) {
      super$initialize(font_style = font_style, text_align = text_align,
        text_color = text_color, js_callbacks = js_callbacks, name = name,
        tags = tags, id = id)
      private$format <- validate(format, "String")
      private$language <- validate(language, "Enum ( NumeralLanguage  )")
      private$rounding <- validate(rounding, "Enum ( RoundingFunction  )")
    }
  ),
  private = list(
    # The number format, as defined in the following tables: NUMBERS:
    # CURRENCY: BYTES: PERCENTAGES: TIME: For the complete specification, see
    # http://numbrojs.com/format.html
    format = NULL, # String
    # The language to use for formatting language-specific features (e.g.
    # thousands separator).
    language = NULL, # Enum ( NumeralLanguage  )
    # Rounding functions (round, floor, ceil) and their synonyms (nearest,
    # rounddown, roundup).
    rounding = NULL # Enum ( RoundingFunction  )
  )
)

# IntEditor optimized for editing percentages.
PercentEditor <- R6::R6Class("PercentEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Select cell editor.
SelectEditor <- R6::R6Class("SelectEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, options = list()
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$options <- validate(options, "List ( String  )")
    }
  ),
  private = list(
    # The list of options to select from.
    options = NULL # List ( String  )
  )
)

# Basic string cell editor with auto-completion.
StringEditor <- R6::R6Class("StringEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, completions = list()
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$completions <- validate(completions, "List ( String  )")
    }
  ),
  private = list(
    # An optional list of completion strings.
    completions = NULL # List ( String  )
  )
)

# Basic string cell formatter.
StringFormatter <- R6::R6Class("StringFormatter",
  inherit = CellFormatter,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, font_style = "normal", text_align = "left",
      text_color = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$font_style <- validate(font_style, "Enum ( FontStyle  )")
      private$text_align <- validate(text_align, "Enum ( TextAlign  )")
      private$text_color <- validate(text_color, "Color")
    }
  ),
  private = list(
    # An optional text font style, e.g. bold, italic.
    font_style = NULL, # Enum ( FontStyle  )
    # An optional text align, i.e. left, center or right.
    text_align = NULL, # Enum ( TextAlign  )
    # An optional text color. See bokeh.core.properties.Color for details.
    text_color = NULL # Color
  )
)

# Table column widget.
TableColumn <- R6::R6Class("TableColumn",
  inherit = Model,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA, default_sort = "ascending", editor = NA,
      field = NA, formatter = NA, sortable = TRUE, title = NA, width = 300L
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)
      private$default_sort <- validate(default_sort, "Enum ( Enumeration(ascending, descending) )")
      private$editor <- validate(editor, "Instance ( CellEditor  )")
      private$field <- validate(field, "String")
      private$formatter <- validate(formatter, "Instance ( CellFormatter  )")
      private$sortable <- validate(sortable, "Bool")
      private$title <- validate(title, "String")
      private$width <- validate(width, "Int")
    }
  ),
  private = list(
    # The default sorting order. By default ascending order is used.
    default_sort = NULL, # Enum ( Enumeration(ascending, descending) )
    # The cell editor for this column. By default, a simple string editor is
    # used.
    editor = NULL, # Instance ( CellEditor  )
    # The name of the field mapping to a column in the data source.
    field = NULL, # String
    # The cell formatter for this column. By default, a simple string
    # formatter is used.
    formatter = NULL, # Instance ( CellFormatter  )
    # Whether this column is sortable or not. Note that data table has to
    # have sorting enabled to allow sorting in general.
    sortable = NULL, # Bool
    # The title of this column. If not set, column’s data field is used
    # instead.
    title = NULL, # String
    # The width or maximum width (depending on data table’s configuration) in
    # pixels of this column.
    width = NULL # Int
  )
)

# Abstract base class for data table (data grid) widgets.
TableWidget <- R6::R6Class("TableWidget",
  inherit = Widget,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA, source = NA
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)
      private$source <- validate(source, "Instance ( DataSource  )")
    }
  ),
  private = list(
    # The source of data for the widget.
    source = NULL # Instance ( DataSource  )
  )
)

# Multi-line string cell editor.
TextEditor <- R6::R6Class("TextEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# Spinner-based time cell editor.
TimeEditor <- R6::R6Class("TimeEditor",
  inherit = CellEditor,
  public = list(
    initialize = function(
      js_callbacks = structure(list(), .Names = character(0)), name = NA,
      tags = list(), id = NA
    ) {
      super$initialize(js_callbacks = js_callbacks, name = name, tags = tags,
        id = id)

    }
  ),
  private = list(

  )
)

# A base class for all interactive widget types.
Widget <- R6::R6Class("Widget",
  inherit = LayoutDOM,
  public = list(
    initialize = function(
      css_classes = NA, disabled = FALSE, height = NA, sizing_mode = "fixed",
      width = NA, js_callbacks = structure(list(), .Names = character(0)),
      name = NA, tags = list(), id = NA
    ) {
      super$initialize(css_classes = css_classes, disabled = disabled,
        height = height, sizing_mode = sizing_mode, width = width,
        js_callbacks = js_callbacks, name = name, tags = tags, id = id)

    }
  ),
  private = list(

  )
)

